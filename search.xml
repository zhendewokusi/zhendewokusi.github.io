<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<span id="more"></span></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>函数声明</title>
    <url>/2023/10/11/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<h3 id="正确理解函数声明"><a href="#正确理解函数声明" class="headerlink" title="正确理解函数声明"></a>正确理解函数声明</h3><p>看书的时候看到一个很抽象的语句：<br><code>(*(void(*)())0)();</code><br>想必每个C程序员看到这条语句都会觉得难绷。这个表达式实际上是在尝试调用位于地址0处的函数指针。在大多数操作系统中，访问地址0通常是非法的，因为它可能导致程序崩溃或产生未定义的行为。这种操作在一些特殊的底层编程场景中可能有用，但在通常的应用程序中应该避免使用，因为它不安全且不可移植。</p>
<span id="more"></span>


<p>请各位牢记一条十分简单的规则：<strong>按照使用的方式来声明。</strong></p>
<h4 id="声明符与表达式"><a href="#声明符与表达式" class="headerlink" title="声明符与表达式"></a>声明符与表达式</h4><p>声明符（Declaration Specifier）和表达式（Expression）是编程中的两个不同概念，它们有以下异同点：</p>
<p><strong>相同点</strong>：</p>
<ol>
<li><p><strong>语法元素</strong>：声明符和表达式都是编程语言的语法元素，它们用于构建和操作程序中的数据和操作。</p>
</li>
<li><p><strong>用途</strong>：声明符用于声明（或定义）变量、函数、类型或其他标识符，以便程序正确识别和使用这些标识符。表达式用于表示和计算值，它可以包括操作数和操作符，用于执行特定的计算操作。</p>
</li>
</ol>
<p><strong>不同点</strong>：</p>
<ol>
<li><p><strong>含义和作用</strong>：</p>
<ul>
<li><strong>声明符</strong> 用于描述标识符的性质和类型，但不执行计算或操作。它告诉编译器如何分配内存和如何解释标识符的内容。</li>
<li><strong>表达式</strong> 用于表示和计算值，执行特定的计算操作，返回一个结果。表达式可以包括常量、变量、运算符和函数调用等，用于生成新的值。</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
<ul>
<li>声明符示例：<code>int x;</code>（声明一个整数变量x）、<code>void myFunction();</code>（声明一个没有返回值的函数myFunction）。</li>
<li>表达式示例：<code>x + 5</code>（计算x与5的和，返回一个值）、<code>myFunction()</code>（调用函数myFunction，返回其结果）。</li>
</ul>
</li>
<li><p><strong>上下文</strong>：</p>
<ul>
<li><strong>声明符</strong> 通常出现在变量、函数、类型或其他标识符的声明语句中，例如在变量声明、函数原型、结构体定义等地方。</li>
<li><strong>表达式</strong> 通常出现在赋值语句、算术运算、逻辑运算、函数调用等地方，用于执行操作和计算值。</li>
</ul>
</li>
</ol>
<p>总之，声明符用于描述标识符的性质和类型，而表达式用于表示和计算值。它们在编程中扮演不同的角色，但都是构建程序逻辑的重要组成部分。</p>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>任何的C变量的声明都由两部分组成：类型，声明符。最简单的声明符就是单个变量，比如：</p>
<p><code>int tmp;</code></p>
<p>这个声明的含义是：当对其求值时，tmp的类型是<code>int</code>。<br>当然也可以这样写：</p>
<p><code>int ((tmp));</code></p>
<p>这个声明的含义是：当对其求值时，((tmp))的类型是<code>int</code>型，因此也可以推出来tmp的类型是<code>int</code>。<br>同理的逻辑也适用于函数和指针的声明：</p>
<p><code>double func();</code></p>
<p>这个声明的含义是：<code>func()</code>求值的结果是<code>double</code>类型。也就是说，<code>func</code>是一个返回值为<code>double</code>类型的函数。</p>
<p><code>int* p;</code></p>
<p>这个声明的含义是：<code>*p</code>是一个<code>int</code>型数据。也就是说，<code>p</code>是一个指向<code>int</code>型数据的指针。</p>
<p>将上面的声明组合一下：</p>
<p><code>double *func2(),(*func3)();</code></p>
<p>表示<code>*func2()</code>和<code>(*func3())</code>都是浮点类型的声明符。因为<code>()</code>优先级高于<code>*</code>，可以得出：<br><code>func2</code>是一个函数，该函数的返回值是指向<code>double</code>类型数据的指针。<br><code>func3</code>是一个函数指针，其指向的函数的返回值类型是<code>double</code>。</p>
<h4 id="类型转换符"><a href="#类型转换符" class="headerlink" title="类型转换符"></a>类型转换符</h4><p>类型转换符是一种在编程语言中用于改变一个值的数据类型的操作符或关键字。类型转换符允许程序员显式地指定将一个数据类型转换为另一个数据类型的方式。这种操作通常称为类型转换或强制类型转换。在理解了上面的知识点后，如果得到一个声明好的、给定类型的变量，得到它的类型转换符也就不是一件难事。例如：</p>
<p><code>float (*tmp)();</code></p>
<p>表示<code>tmp</code>是一个指向返回值为<code>float</code>类型的函数的指针，那么：</p>
<p><code>float (*)()</code></p>
<p>也就表示为一个“一个指向返回值为<code>float</code>类型的函数的指针”的类型转换符。</p>
<p>可以看下面代码再练习练习：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myFunction</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数实现</span></span><br><span class="line">    <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个函数指针，并初始化为指向myFunction的指针</span></span><br><span class="line">    <span class="type">int</span> (*h)(<span class="type">char</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="comment">// 这里的myFunction的类型就是 int (*)(char *, int),为了便于理解我就全部写出来了</span></span><br><span class="line">    h = (<span class="type">int</span> (*)(<span class="type">char</span> *, <span class="type">int</span>))myFunction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在可以使用h来调用函数</span></span><br><span class="line">    <span class="type">int</span> result = h(<span class="string">&quot;Hello&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p><code>(*fp)();</code></p>
<p>fp是一个<strong>函数指针</strong>，那么<code>*fp</code>就是该指针指向的函数，所以<code>(*fp)()</code>就是调用这个函数的方式。但是，ANSI C 标准允许程序员将上式子简写成<code>fp()</code>，这只是一种<strong>简写</strong>。</p>
<p>看的仔细的读者就会发现，我上面代码调用函数也使用了简写。因此我上面的代码中：<code>int result = h(&quot;Hello&quot;, 1);</code>实际上是<code>int result = (*h)(&quot;Hello&quot;, 1);</code>。</p>
<h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p><code>(*(void(*)())0)();</code>被设计的目的是为了在计算机启动的时候，硬件将调用首地址为0位置的子例程。</p>
<p>你可能会想，为什么不直接：</p>
<p><code>(* 0)()</code></p>
<p>可惜编译器是笨重的。因为运算符<code>*</code>必须要一个指针来进行解引用。而且这个指针还应该是一个函数指针，这样经过运算符<code>*</code>作用后的结果才能作为函数被调用。因此，上式子对<code>0</code>要进行强制类型转换为一个“指向返回值为void类型的函数的指针”。因此就有了下式：</p>
<p><code>(*(void(*)())0)();</code>,让我解释一下这个表达式的各个部分：</p>
<ol>
<li><p><code>void(*)()</code>：这部分表示一个函数指针类型，它指向一个没有参数并且没有返回值的函数。这是一个函数指针类型的定义，但没有指向任何有效函数。</p>
</li>
<li><p><code>0</code>：这是一个空指针，它不指向任何内存地址。</p>
</li>
<li><p><code>(*(void(*)())0)</code>：这部分将空指针转换为一个函数指针，然后尝试通过解引用这个函数指针来调用一个函数。</p>
</li>
<li><p>最后的 <code>();</code> 尝试调用解引用的函数指针，但由于函数指针不指向有效函数，这会导致未定义行为，通常会导致程序崩溃或其他不可预测的结果。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>地址、section、vstart</title>
    <url>/2023/10/14/%E5%9C%B0%E5%9D%80%E3%80%81section%E3%80%81vstart/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我在学习汇编的时候，对于<code>vstart</code>的概念其实很模糊，感觉会又感觉不是很会，要说哪儿不会有说不出来，就很难受。<code>vstart</code>是<code>section</code>中的概念，但是要讲清楚什么是<code>section</code>，就必须说说什么是地址了。</p>
<span id="more"></span>

<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><h4 id="地址的概念"><a href="#地址的概念" class="headerlink" title="地址的概念"></a>地址的概念</h4><p>计算机里面只有0和1,地址当然就是一串数字，这串数字用来描述各种符号在源程序中的位置。地址细分又能分为：物理地址、虚拟地址布拉布拉的，这里不做深究。</p>
<p>在汇编中，由于指令和变量占据的内存大小不一样，总不能想怎么来就怎么来，那么就得有一套统一的规则来分配。程序中各种数据结构的访问，本质上是通过“该数据结构的起始地址 + 该数据结构在该硬件平台规定的变量所占据的内存大小”来实现的。这里也就解释了，为什么<code>C语言</code>等高级语言中为什么要定义变量的类型，因为这样才能正确的分配和访问变量占据的内存。</p>
<p>那么这里的起始地址是如何得到的呢？编译器在做这件事情的时候，占据第一位的数据的地址便是整个程序的起始地址，后面的数据都是在它基础上的偏移。第n个数据所在的位置就是：第n-1个数据的偏移 + 数据 n-1 的内存空间，这就是所谓的<strong>偏移量</strong>，每个变量的地址都是前一个变量的地址 + 前一个变量的内存空间大小。</p>
<h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><p>来看个简单例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  mov ax,$$</span><br><span class="line">  mov ds,ax</span><br><span class="line">  mov ax,[var]</span><br><span class="line">  label : mov ax,$</span><br><span class="line">  jmp label</span><br><span class="line">  var dw 0x99</span><br><span class="line">  infi: jmp near infi                 ;无限循环</span><br><span class="line"></span><br><span class="line">times (510-($-$$)) db 0               ;主引导程序512字节，空余的使用0填充</span><br><span class="line">          db 0x55,0xaa                ;结束标志               </span><br></pre></td></tr></table></figure>
<p>下面将其放在bochs中进行调试的输出信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;bochs:1&gt; b 0x07c00</span><br><span class="line">&lt;bochs:2&gt; c</span><br><span class="line">(0) Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">Next at t=17178863</span><br><span class="line">(0) [0x000000007c00] 0000:7c00 (unk. ctxt): mov ax, 0x0000            ; b80000</span><br><span class="line">&lt;bochs:3&gt; n</span><br><span class="line">Next at t=17178864</span><br><span class="line">(0) [0x000000007c03] 0000:7c03 (unk. ctxt): mov ds, ax                ; 8ed8</span><br><span class="line">&lt;bochs:4&gt; </span><br><span class="line">Next at t=17178865</span><br><span class="line">(0) [0x000000007c05] 0000:7c05 (unk. ctxt): mov ax, word ptr ds:0x000d ; a10d00</span><br><span class="line">&lt;bochs:5&gt; </span><br><span class="line">Next at t=17178866</span><br><span class="line">(0) [0x000000007c08] 0000:7c08 (unk. ctxt): mov ax, 0x0008            ; b80800</span><br><span class="line">&lt;bochs:6&gt; </span><br><span class="line">Next at t=17178867</span><br><span class="line">(0) [0x000000007c0b] 0000:7c0b (unk. ctxt): jmp .-5  (0x00007c08)     ; ebfb</span><br><span class="line">&lt;bochs:7&gt; </span><br><span class="line">Next at t=17178868</span><br><span class="line">(0) [0x000000007c08] 0000:7c08 (unk. ctxt): mov ax, 0x0008            ; b80800</span><br><span class="line">&lt;bochs:8&gt; </span><br><span class="line">Next at t=17178869</span><br><span class="line">(0) [0x000000007c0b] 0000:7c0b (unk. ctxt): jmp .-5  (0x00007c08)     ; ebfb</span><br></pre></td></tr></table></figure>
<p>可以看到第一行的mov指令，<code>$$</code>被替换成了<code>0</code>。默认情况下如果程序没有定义<code>section</code>就将所有的文件当作一个大的<code>section</code>，因此此时<code>$$</code>为<code>0</code>。</p>
<p>第三行引用了<code>var</code>变量的值，而<code>[]</code>是去所在地址的内容。<code>mov ax, word ptr ds:0x000d ;</code>就是表明要将一个16位的数据从内存地址 <code>0x000d</code> 处加载到寄存器 <code>AX</code> 中。至于为什么是<code>0x000d</code>后面会解释。</p>
<p>第四行用了一个<code>$</code>标号，代表当前指令所在的地址。</p>
<p>最后一行就是一个数据的定义，没什么好讲的。</p>
<p>还记得上面讲的地址的计算吗？看调试第一行的左侧的地址<code>0x000000007c00</code>和第二行地址<code>0x000000007c03</code>，这两个之间相差3,而第一个指令转换成机器码是<code>b80000</code>刚好三个字节。有没有理解计算机的地址了？再依次往下算，刚好<code>var dw 0x99</code>的地址就是<code>0x000000007c0b</code> + 对应的机器码<code>ebfb</code>的长度，也就是<code>0x000000007c0d</code>，就将这个结果<code>0x000000007c0d - 0x000000007c00</code> 后得到的偏移量是不是 <code>0x000d</code>，也就是变量<code>var</code>的地址。</p>
<h3 id="section"><a href="#section" class="headerlink" title="section"></a>section</h3><p>我刚开始对<code>section</code>感觉就是在似懂非懂，这个东西称为节。编译器提供的这个关键字只是给程序员用的，处理器根本不知道有这么个东西，你会想：既然CPU又不知道这么个东西，我用不用<code>section</code>都行吧。是这样的，但是最好使用，因为<code>section</code>的功能类似与函数，人为的将代码划分为不同的部分，都是为了代码结构清晰，易于维护。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTION code</span><br><span class="line">    mov ax,$$</span><br><span class="line">    mov ax,section.data.start</span><br><span class="line">    mov ax,section.code.start</span><br><span class="line">    mov ax,[var1]</span><br><span class="line">    label: jmp label</span><br><span class="line"></span><br><span class="line">    infi: jmp near infi                 ;无限循环</span><br><span class="line"> </span><br><span class="line">  times (510-($-$$)) db 0</span><br><span class="line">            db 0x55,0xaa</span><br><span class="line"></span><br><span class="line">SECTION data</span><br><span class="line">    var1 dd 0x4</span><br></pre></td></tr></table></figure>
<p>下面将其放在bochs中进行调试的输出信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0</span><br><span class="line">&lt;bochs:1&gt; b 0x07c00</span><br><span class="line">&lt;bochs:2&gt; c</span><br><span class="line">(0) Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">Next at t=17178863</span><br><span class="line">(0) [0x000000007c00] 0000:7c00 (unk. ctxt): mov ax, 0x0000            ; b80000</span><br><span class="line">&lt;bochs:3&gt; n</span><br><span class="line">Next at t=17178864</span><br><span class="line">(0) [0x000000007c03] 0000:7c03 (unk. ctxt): mov ax, 0x0200            ; b80002</span><br><span class="line">&lt;bochs:4&gt; </span><br><span class="line">Next at t=17178865</span><br><span class="line">(0) [0x000000007c06] 0000:7c06 (unk. ctxt): mov ax, 0x0000            ; b80000</span><br><span class="line">&lt;bochs:5&gt; </span><br><span class="line">Next at t=17178866</span><br><span class="line">(0) [0x000000007c09] 0000:7c09 (unk. ctxt): mov ax, word ptr ds:0x0200 ; a10002</span><br><span class="line">&lt;bochs:6&gt; </span><br><span class="line">Next at t=17178867</span><br><span class="line">(0) [0x000000007c0c] 0000:7c0c (unk. ctxt): jmp .-2  (0x00007c0c)     ; ebfe</span><br><span class="line">&lt;bochs:7&gt; </span><br><span class="line">Next at t=17178868</span><br><span class="line">(0) [0x000000007c0c] 0000:7c0c (unk. ctxt): jmp .-2  (0x00007c0c)     ; ebfe</span><br></pre></td></tr></table></figure>

<p>在调试信息中我们注意到：</p>
<ul>
<li><p><code>SECTION code</code> 和 <code>SECTION data</code> 一个字节的机器码都没有产生，也印证了前面说的处理器并不知道有<code>SECTION</code>的存在。</p>
</li>
<li><p><code>section.data.start</code>实际上就是本文件中名为<code>data</code>的<code>section</code>的真实偏移。这个或许看不出来，可以看<code>mov ax,section.code.start</code>的偏移，也就是调试信息中的<code>0000:7c06 (unk. ctxt): mov ax, 0x0000</code>，可以看到<code>code</code>的偏移量为0，符合我们的预期。</p>
</li>
</ul>
<h3 id="vstart"><a href="#vstart" class="headerlink" title="vstart"></a>vstart</h3><p>根据nasm官方手册的解释：<code>section</code>使用<code>vstart</code>修饰后，就可以被赋予一个虚拟起始地址<code>virtual start address</code>。而<code>org</code>和<code>vstart</code>实际上是同一功能，我就只展示其中一个，另外一个原理相同。</p>
<p>特别需要注意的是：<code>vstart</code>和<code>org</code>都不会让程序加载到地址xxx。它们做的只是告诉编译器将这个节之后的数据、指令的地址按照xxx为起始，就这么个功能。而加载是加载器的功能，编译器没这本事。</p>
<p>光听概念太枯燥，还是来看个代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTION code vstart=0x7c00</span><br><span class="line">    mov ax,$$</span><br><span class="line">    mov ax,section.data.start</span><br><span class="line">    mov ax,section.code.start</span><br><span class="line">    mov ax,[var1]</span><br><span class="line">    label: jmp label</span><br><span class="line"></span><br><span class="line">    infi: jmp near infi                 ;无限循环</span><br><span class="line"> </span><br><span class="line">  times (510-($-$$)) db 0</span><br><span class="line">            db 0x55,0xaa</span><br><span class="line"></span><br><span class="line">SECTION data </span><br><span class="line">    var1 dd 0x4</span><br></pre></td></tr></table></figure>
<p>下面将其放在bochs中进行调试的输出信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0</span><br><span class="line">&lt;bochs:1&gt; b 0x07c00</span><br><span class="line">&lt;bochs:2&gt; c</span><br><span class="line">(0) Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">Next at t=17178863</span><br><span class="line">(0) [0x000000007c00] 0000:7c00 (unk. ctxt): mov ax, 0x7c00            ; b8007c</span><br><span class="line">&lt;bochs:3&gt; n</span><br><span class="line">Next at t=17178864</span><br><span class="line">(0) [0x000000007c03] 0000:7c03 (unk. ctxt): mov ax, 0x0200            ; b80002</span><br><span class="line">&lt;bochs:4&gt; </span><br><span class="line">Next at t=17178865</span><br><span class="line">(0) [0x000000007c06] 0000:7c06 (unk. ctxt): mov ax, 0x0000            ; b80000</span><br><span class="line">&lt;bochs:5&gt; </span><br><span class="line">Next at t=17178866</span><br><span class="line">(0) [0x000000007c09] 0000:7c09 (unk. ctxt): mov ax, word ptr ds:0x0900 ; a10009</span><br><span class="line">&lt;bochs:6&gt; </span><br><span class="line">Next at t=17178867</span><br><span class="line">(0) [0x000000007c0c] 0000:7c0c (unk. ctxt): jmp .-2  (0x00007c0c)     ; ebfe</span><br><span class="line">&lt;bochs:7&gt; </span><br><span class="line">Next at t=17178868</span><br><span class="line">(0) [0x000000007c0c] 0000:7c0c (unk. ctxt): jmp .-2  (0x00007c0c)     ; ebfe</span><br></pre></td></tr></table></figure>

<p>可以看到<code>code</code>加了<code>vstart</code>后，<code>$$</code>从<code>0</code>变成<code>0x7c00</code>。所以该节中的数据地址从<code>0x7c00</code>为起始编址。这个是虚拟的地址，因为这个程序整个才512字节，根本到不了偏移量为<code>0x7c00</code>。<code>$$</code>以该节的虚拟起始地址为主，如果这个节没有<code>vstart</code>来指定起始地址，就输出在文件中偏移地址。而此时的<code>$</code>就是 当前的新的地址 + 偏移。 </p>
<p><code>section.data.start</code>实际上就是本文件中名为<code>data</code>的<code>section</code>的真实偏移，没有因为<code>vstart</code>改变。</p>
]]></content>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>条款 21 :优先选用 std::make_unique 和std::make_shared, 而非直接使用 new</title>
    <url>/2023/10/09/%E6%9D%A1%E6%AC%BE21/</url>
    <content><![CDATA[<h4 id="使用std-make-shared的理由-代码精简"><a href="#使用std-make-shared的理由-代码精简" class="headerlink" title="使用std::make_shared的理由:代码精简"></a>使用std::make_shared的理由:代码精简</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">upw1</span><span class="params">(std::make_unique&lt;Widget&gt;())</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget&gt; <span class="title">upw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">spw1</span><span class="params">(std::make_shared&lt;Widget&gt;())</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用make系列函数只有一个Widget,代码风格不冗余。</p>
<span id="more"></span>

<h4 id="使用std-make-shared的理由-异常安全性"><a href="#使用std-make-shared的理由-异常安全性" class="headerlink" title="使用std::make_shared的理由:异常安全性"></a>使用std::make_shared的理由:异常安全性</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(std::shared_ptr&lt;MyClass&gt; share_p , <span class="type">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test1</span>(std::<span class="built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="keyword">new</span> MyClass),<span class="built_in">test2</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面代码可能会造成内存泄漏.这和编译器从源代码到目标代码的翻译有关系<br>理想情况test1()运行前发生:</p>
<ol>
<li>“new MyClass”完成评估求值(在堆创建)</li>
<li>new 出来的裸指针被shared_ptr托管(运行shared_ptr的构造函数)</li>
<li>运行test2()<br>而编译器不必按照上述顺序生成代码.当然”new MyClass”必须在shared_ptr的构造函数调用前执行完,但是test2()并没有强制它的运行顺序,也就是说test2()可能在1和2的调用前,调用后,甚至1和2调用之间执行.你可能觉得无伤大雅,但是如果test2()在运行时产生了异常呢?<br>此时第一步动态分配的MyClass会被泄漏.</li>
</ol>
<h5 id="如何解决这个问题呢"><a href="#如何解决这个问题呢" class="headerlink" title="如何解决这个问题呢?"></a>如何解决这个问题呢?</h5><h6 id="分开写"><a href="#分开写" class="headerlink" title="分开写"></a>分开写</h6><p>没错,编译器分不清顺序,你就让它分清就好了,将单独的语句改写成多行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> MyClass,MyDel)</span></span>;<span class="comment">//MyDel是自定义析构器</span></span><br><span class="line"><span class="built_in">test1</span>(std::<span class="built_in">move</span>(spw),<span class="built_in">test2</span>());                  <span class="comment">//移动可以提高效率,并且防止复制对引用计数进行原子的递增操</span></span><br></pre></td></tr></table></figure>
<h6 id="使用std-make-shared"><a href="#使用std-make-shared" class="headerlink" title="使用std::make_shared"></a>使用std::make_shared</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test1</span>(std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(),<span class="built_in">test2</span>());</span><br></pre></td></tr></table></figure>
<p>这里如果test2()先运行且异常,动态还没分配MyClass<br>如果先运行std::make_shared<MyClass>(),动态分配的裸指针会安全的存储在std::shared_ptr对象中,之后test2()异常也能正常析构<br>.<em>std::unique_ptr和std::make_unique同理</em></p>
<h4 id="使用std-make-shared的另一个理由-性能提升"><a href="#使用std-make-shared的另一个理由-性能提升" class="headerlink" title="使用std::make_shared的另一个理由:性能提升"></a>使用std::make_shared的另一个理由:性能提升</h4><p>shared_ptr 直接使用 new 表达式的话,除了要为 MyClass 进行一次内存分配,还要为与其相关联的控制块再进行一次内存分配.<br>而使用make_shared来代替new表达式的话,仅仅需要一次内存分配.</p>
<h4 id="make系列函数也不是万能的"><a href="#make系列函数也不是万能的" class="headerlink" title="make系列函数也不是万能的"></a>make系列函数也不是万能的</h4><p>说了这么多,make系列的函数无论是在异常安全,效率,避免代码冗余都有优势,但是不能排他性的只用make系列函数,因为有些情景下不能使用make系列函数.比如,自定义析构器,无法完美转发大括号初始化物,定义自身版本的operator new和operator delete(shared_ptr).<br>对于operator new和operator delete这种边缘情况就不做解释,知道有这么个东西就可以了.</p>
<h5 id="自定义析构器"><a href="#自定义析构器" class="headerlink" title="自定义析构器"></a>自定义析构器</h5><p>所有的make系列函数不允许使用自定义析构器. std::unique_ptr 和 std::shared_ptr 却都有着允许使用自定义析构器的构造函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> MyDel = [](MyClass* pw) &#123;...&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;MyClass, <span class="title">decltype</span><span class="params">(MyDel)</span>&gt; <span class="title">upw</span><span class="params">(<span class="keyword">new</span> MyClass, MyDel)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> MyClass, MyDel)</span></span>;  <span class="comment">// MyDel是自定义析构器</span></span><br><span class="line"><span class="built_in">test1</span>(std::<span class="built_in">move</span>(spw),<span class="built_in">test2</span>());  <span class="comment">// 移动可以提高效率,并且防止复制对引用计数进行原子的递增操</span></span><br></pre></td></tr></table></figure>
<h5 id="不能完美转发大括号初始化物"><a href="#不能完美转发大括号初始化物" class="headerlink" title="不能完美转发大括号初始化物"></a>不能完美转发大括号初始化物</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> upv = std::make_unique&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>最终upv指涉到的是一个包含10个元素,每个元素值都为20的vector?还是包含两个元素,分别是10,20的vector?但是不能完美转发大括号初始化物该怎么办?<br>答案是make系列的函数对形参进行完美转发的代码使用的是圆括号而非大括号.所以是一个包含10个元素,每个元素值都为20的vector.也不是不能完美转发,变通以下还是可以的.比如下面的test1()创建一个std::initializer_list对象,并且利用std::initializer_list型别的构造函数构造vector.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> upv =</span><br><span class="line">        std::make_unique&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(std::initializer_list&lt;<span class="type">int</span>&gt;&#123;<span class="number">10</span>, <span class="number">20</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> initlist = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(initlist);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::unique_ptr elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : *upv) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::shared_ptr elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : *spv) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> upv = std::make_unique&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::unique_ptr elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : *upv) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::shared_ptr elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : *spv) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次运行test1()和test2()得到的结果是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  tmp git:(main) ✗ ./tmp</span><br><span class="line">std::unique_ptr elements: 10 20 </span><br><span class="line">std::shared_ptr elements: 10 20 </span><br><span class="line">std::unique_ptr elements: 20 20 20 20 20 20 20 20 20 20 </span><br><span class="line">std::shared_ptr elements: 20 20 20 20 20 20 20 20 20 20</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> initlist = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(initlist);</span><br></pre></td></tr></table></figure>
<p>对于test1()中upv和spv的初始化,我更希望能使用第二种,没有人会想写第一种那么复杂的代码的.示例代码仅仅展示auto推导出来的类型.</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>条款23：理解std::move 和 std::forward</title>
    <url>/2023/10/09/%E6%9D%A1%E6%AC%BE23/</url>
    <content><![CDATA[<h3 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h3><p><code>std::move</code> 不做任何移动， <code>std::forward</code> 不做任何转发。它们在运行的时候什么都没干。<br>它们两个都只做了<strong>强制类型转换</strong>，<code>std::move</code> 无条件将实参强制转换成右值，<code>std::forward</code> 是有条件的执行强制类型转换。</p>
<span id="more"></span>
<h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><p>我们来看一看<code>c++11</code>中std::move的示例实现:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也和条款9呼应，也就是别名声明(<code>using</code>)压倒<code>typedef</code>的优势：支持模板化！而<code>typedef</code>需要结构体来辅助完成同样功能。如果我们要使用<code>typedef</code>来实现同样的功能的话，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StructReturnType</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> StructReturnType&lt;T&gt;::type&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果是<code>c++14</code>，有了返回值型别推导，实现<code>std::move</code>就更加方便：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = std::<span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span>&amp; x_ref = x;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; rvalue_ref_1 = <span class="built_in">move</span>(x);       <span class="comment">//编译通过，说明强制转换成功</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; rvalue_ref_2 = <span class="built_in">move</span>(x_ref);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::move</code><strong>只做强制类型转换，不做移动</strong>。当然右值是可以实施移动的，所以一个对象实施了<code>std::move</code>后就告诉编译器该对象可能具备移动的条件。为什么是可能呢？通常情况下的确没有问题，具备移动的条件。看下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(std::string tmp)</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的<code>explicit</code> 是一个关键字，通常用于类的构造函数声明中，用于阻止隐式类型转换。当一个构造函数被标记为 <code>explicit</code> 时，它告诉编译器不要执行隐式类型转换，只有显式调用时才会使用该构造函数。</p>
<p><code>Entity</code>类的构造函数不需要修改<code>tmp</code>，根据优良传统“只要有可能使用<code>const</code>就使用”，将代码更改成了下面的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="type">const</span> std::string tmp)</span></span></span><br><span class="line"><span class="function">    : value(std::move(tmp))&#123;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码顺利运行，但是<code>tmp</code>是被复制近<code>value</code>的，而不是移动。<code>std::move(tmp)</code>后结果是右值<code>const std::string</code>，常量性保留下来了。<br>可以浅浅的看一下string的头文件:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//string 文件</span></span><br><span class="line">   <span class="keyword">using</span> string    = basic_string&lt;<span class="type">char</span>&gt;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//basic_string.h 文件</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//复制构造函数</span></span><br><span class="line">   <span class="built_in">basic_string</span>(<span class="type">const</span> basic_string&amp; __str)</span><br><span class="line">     : _M_dataplus(_M_local_data(),</span><br><span class="line">	    _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))</span><br><span class="line">     &#123;</span><br><span class="line">_M_construct(__str._M_data(), __str._M_data() + __str.<span class="built_in">length</span>(),</span><br><span class="line">	     std::forward_iterator_tag());</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//移动构造函数</span></span><br><span class="line">   <span class="built_in">basic_string</span>(basic_string&amp;&amp; __str) <span class="keyword">noexcept</span></span><br><span class="line">     : _M_dataplus(_M_local_data(), std::<span class="built_in">move</span>(__str._M_get_allocator()))</span><br><span class="line">     &#123;</span><br><span class="line"><span class="keyword">if</span> (__str._M_is_local())</span><br><span class="line">  &#123;</span><br><span class="line">    traits_type::<span class="built_in">copy</span>(_M_local_buf, __str._M_local_buf,</span><br><span class="line">		      __str.<span class="built_in">length</span>() + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _M_data(__str._M_data());</span><br><span class="line">    _M_capacity(__str._M_allocated_capacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Must use _M_length() here not _M_set_length() because</span></span><br><span class="line"><span class="comment">// basic_stringbuf relies on writing into unallocated capacity so</span></span><br><span class="line"><span class="comment">// we mess up the contents if we put a &#x27;\0&#x27; in the string.</span></span><br><span class="line">_M_length(__str.<span class="built_in">length</span>());</span><br><span class="line">__str._M_data(__str._M_local_data());</span><br><span class="line">__str._M_set_length(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到移动构造的函数只能接受非常量的<code>string</code>类型的右值引用作为形参。因为指涉到常量的左值引用允许绑定在一个常量右值性别的形参，最终调用的是<code>string</code>的复制构造函数（即使tmp为右值）。</p>
<p>通过这个例子，我们可以学习到：</p>
<ul>
<li>如果想取得对某个对象执行移动操作的能力，不要将其声明为常量。</li>
<li><code>std::move</code>不能保证强制型别转换的对象具备可移动的能力。</li>
<li>唯一可以确定的，结果是个右值。</li>
</ul>
<h3 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h3><p>需要注意的是：传递给 std::forward 的实参型别应当是个非引用型别,因为习惯上它编码的所传递<br>实参应该是个右值(参见条款 28)。<br><code>std::forward</code> 仅仅在特定情况下会实施强制类型转换。最常见的就是某个函数模板取用了万能引用型别作为形参，传递给另一个函数,如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> Entity&amp; left)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Entity&amp;&amp; right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">func</span>(param);</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Entity <span class="title">e</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="built_in">func2</span>(e);</span><br><span class="line">    <span class="built_in">func2</span>(std::<span class="built_in">move</span>(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望<code>func2</code>传入的是一个左值时，执行<code>func</code>的左值的版本，传入的是个右值的时候执行<code>func</code>重载的右值的版本。但是函数形参都是左值，也就是说这里的<code>param</code>一直是左值，不论传入<code>func2</code>的是左值还是右值，都只会执行<code>func</code>的左值版本。此时，<code>std::forward</code>就做到了这件事：仅当实参是右值完成初始化的时候才会执行向右值的强制类型转换。</p>
<p>那么<code>std::forward</code>是如何知道实参是否通过右值来完成初始化的呢？其实是通过传入的函数模板形参<code>T</code>来实现的(详细参见条款 28)。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>条款24:区分万能引用和右值引用</title>
    <url>/2023/10/12/%E6%9D%A1%E6%AC%BE24/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不是所有的<code>&amp;&amp;</code>都是右值引用！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(Widget&amp;&amp; param)</span></span>;    <span class="comment">// 右值引用</span></span><br><span class="line">Widget&amp;&amp; varl = <span class="built_in">Widget</span>();   <span class="comment">// 右值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = van;          <span class="comment">// 不是右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std: :vector&lt;T&gt;&amp;&amp; param)</span></span>;    <span class="comment">// 右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;          <span class="comment">// 不是右值引用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>好了，看完CPU烧了，到底是不是右值引用呀，我也不知道呀。<br>实际上, “ <code>T&amp;&amp;</code> ”有两种不同的含义。其中一种含义,理所当然,是右值引用。正如期望,它们仅仅会绑定到右值,而其主要的存在理由,在于识别出可移对象。“ <code>T&amp;&amp;</code> “的另一种含义,则表示其既可以是右值引用,亦可以是左值引用。它可以绑定到右值，也可以像左值引用一样，也可以绑定在<code>const</code>对象或者非<code>const</code>对象，也可以绑定在<code>volatile</code>对象或者非<code>volatile</code>对象,它灵活度高到被成为<em>万能引用</em>。</p>
<h3 id="万能引用的场景"><a href="#万能引用的场景" class="headerlink" title="万能引用的场景"></a>万能引用的场景</h3><ol>
<li>函数模板的推导</li>
<li>auto声明</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = van;          <span class="comment">// 不是右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;          <span class="comment">// 不是右值引用</span></span><br><span class="line"><span class="comment">//在这种情况下，类型 T 是需要从参数中推导的，因为 param 的类型是未知的，这时编译器将根据参数类型来推导 T 的类型。</span></span><br></pre></td></tr></table></figure>
<p>这两个场景的共同之处：都涉及<strong>型别推导</strong>。如果看到了<code>T&amp;&amp;</code>但是没有型别推导，那么就可以确定是右值引用。</p>
<h3 id="万能引用的条件"><a href="#万能引用的条件" class="headerlink" title="万能引用的条件"></a>万能引用的条件</h3><p>万能引用的特点是它们具有两个条件：</p>
<ol>
<li><p><strong>必须</strong>在模板内进行型别推导：这意味着类型 T 必须在模板函数或模板类内部通过类型推导而不是显式指定。这是因为模板会根据实际传递给函数或类的参数类型来推导 T 的类型。</p>
</li>
<li><p>型别声明的形式<strong>必须</strong>是 <code>T&amp;&amp;</code>：这表示右值引用的声明必须以 T&amp;&amp; 的形式出现，以指示它可以成为万能引用。</p>
</li>
</ol>
<p>如果这两个条件同时满足，那么右值引用就被认为是万能引用。</p>
<p>这也就是为什么上面提到的<code>void f(std: :vector&lt;T&gt;&amp;&amp; param);</code>是右值引用而不是万能引用。它虽然涉及型别推导，但它的型别声明形式不是 <code>T&amp;&amp;</code>，而是 <code>std::vector&lt;T&gt;&amp;&amp;</code>。因此，这只是一个右值引用，而不是万能引用。</p>
<p>即使只是一个<code>const</code>的存在，也不满足条件2,就成为了右值引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;    <span class="comment">//右值引用</span></span><br></pre></td></tr></table></figure>

<p>如果在一个模板内看到一个函数形参为<code>T&amp;&amp;</code>也不能想当然的认为它是万能引用。看下面的例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span> , <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>push_back</code>的形参满足条件，但是条件一：型别推导，它并没有涉及。因为该函数作为<code>vector</code>类的一部分，如果没有特定<code>vector</code>类实例，就没有该函数（C++类的基础）。如果给定一个<code>vector</code>实例，那么<code>push_back</code>的形参就会被具体化。比如给定一个实例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;Entity&gt; entity;</span><br></pre></td></tr></table></figure>
<p>vector模板就会被具化为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&lt;Entity, allocator&lt;Entity&gt;&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(Entity&amp;&amp; x)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>push_back</code>函数并没有涉及类型推导。因此其参数不是万能引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span> , <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">emplace_back</span>(Args&amp;&amp;... args);  <span class="comment">// 万能引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的<code>args</code>涉及到了类型推导，因此是万能引用。</p>
<h4 id="多说一点"><a href="#多说一点" class="headerlink" title="多说一点"></a>多说一点</h4><p>有些人不清楚<code>template&lt;class... Args&gt;</code>中的<code>...</code>是什么，其实很简单，”…” 是用来表示可变参数模板的语法。它用于表示函数或类模板可以接受可变数量的参数。具体来说，<code>Args</code> 是一个参数包，它可以包含零个或多个模板参数。<code>Args&amp;&amp;... args</code> 表示您可以将任意数量的参数传递给 <code>emplace_back</code> 函数，每个参数都会被表示为 <code>Args</code> 类型的右值引用。这种语法通常用于实现”完美转发”。（后面会提到）</p>
<p>而前面提到的另一种场景,auto声明，在<code>C++11</code>中不怎么普遍。而在<code>C++14</code>中，它现身的机会就更多了，因为<code>C++14</code>中的<code>lambda</code>表达式中可以声明<code>auto&amp;&amp; </code>的形参。</p>
<h3 id="万能引用的作用"><a href="#万能引用的作用" class="headerlink" title="万能引用的作用"></a>万能引用的作用</h3><p>这种引用在模板编程中非常有用，因为它们能够保持对传递给它们的参数的左值或右值性质，并且可以实现完美转发，使它们适用于各种不同类型的参数。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>条款25:针对右值引用实施std::move，针对万能引用实施std::forward</title>
    <url>/2023/10/12/%E6%9D%A1%E6%AC%BE25/</url>
    <content><![CDATA[<h3 id="重载？"><a href="#重载？" class="headerlink" title="重载？"></a>重载？</h3><p>在条款23的基础上，再来细说一下<code>std::move</code>和<code>std::forward</code>。看这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = std::<span class="built_in">move</span>(newName);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::shared_ptr&lt;Data&gt; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::string <span class="title">getEntityName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    <span class="keyword">auto</span> n = <span class="built_in">getEntityName</span>();</span><br><span class="line">    e.<span class="built_in">setName</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看着好像一切安好。<span id="more"></span>注意这里的<code>n</code>是局部变量，传递给<code>e.setName()</code>，调用者假定该函数对<code>n</code>只进行读操作是没有任何问题的。但是<code>setName()</code>内部使用了<code>std::move</code>将其引用的形参无条件强转成右值，因此<code>n</code>的数值就会被移入<code>e.name</code>。运行完<code>setName()</code>后，<code>n</code>就成了一个未知数。</p>
<p>你会说：那我为啥要把形参声明称万能引用自讨苦吃，我直接为其分别重载左值和右值两个版本不就好了。你说的对，但是对的很难受。程序运行效率降低是其次，最主要的是代码难以维护以及扩展性太差。</p>
<p>这个例子只有一个形参，还好处理，两个重载版本就行了。那么10个参数的呢？难不成你重载 (2^{10}) 个版本？有啥想不开的非要这么折磨自己。更别说有些函数模板会有无穷多个形参（比如：<code>std::make_shared</code>）</p>
<h3 id="万能引用！"><a href="#万能引用！" class="headerlink" title="万能引用！"></a>万能引用！</h3><p>上面的例子修改如下，这样就不需要重载也能实现对应功能了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = std::forward&lt;T&gt;(newName); <span class="comment">// 使用 std::forward 来保持左值或右值性质</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::shared_ptr&lt;Data&gt; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::string <span class="title">getEntityName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;NewName&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    <span class="keyword">auto</span> n = <span class="built_in">getEntityName</span>();</span><br><span class="line">    e.<span class="built_in">setName</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><p>假设在某个函数中，你刚开始只用了一次该对<br>象，之后就对其实施<code>std::move</code>或者<code>std::forward</code>，这没有问题，需要注意的是，随着函数不断完善，如果在该函数中不止一次地绑定到右值引用或者万能引用，就会导致上面变量<code>n</code>就成了一个未知数的错误。因此，在这种情况下，只能在最后一次使用该引用的时候对其实施<code>std::move</code>或者<code>std::forward</code>来确保其他操作时候其值依旧存在。</p>
<h3 id="std-move-if-noexcept"><a href="#std-move-if-noexcept" class="headerlink" title="std::move_if_noexcept"></a>std::move_if_noexcept</h3><p><code>std::move_if_noexcept</code> 通常用于优化移动操作，特别是在异常安全性方面。它可以帮助在一些情况下，当移动操作不会抛出异常时，避免不必要的拷贝。</p>
<p>这个函数的典型用例是在容器类的 <code>emplace_back</code> 和 <code>emplace</code> 成员函数中，这些函数通常要求插入元素时提供的参数（构造元素的参数）不会抛出异常。这样可以确保在插入元素时，如果构造过程抛出异常，容器的状态不会受到破坏，因为元素的构造是在容器内完成的。</p>
<p>考虑以下示例，使用 <code>std::move_if_noexcept</code> 在 <code>emplace_back</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;MyType&gt; myVector;</span><br><span class="line">myVector.<span class="built_in">emplace_back</span>(std::<span class="built_in">move_if_noexcept</span>(someValue));</span><br></pre></td></tr></table></figure>

<p>在这里，<code>std::move_if_noexcept</code> 会检查 <code>someValue</code> 是否可以进行无异常移动，如果可以，它会使用移动操作，否则会进行拷贝操作。这有助于确保异常安全性，以避免在构造元素时抛出异常时，不会破坏容器的状态。</p>
<p>要使用 <code>std::move_if_noexcept</code>，您需要确保在需要优化移动操作的情况下，并且对于元素类型的移动构造函数声明了 <code>noexcept</code> 说明符。这通常是在实现自定义类时要考虑的事情。</p>
<p>总之，<code>std::move_if_noexcept</code> 是一种有助于提高性能并确保异常安全性的工具，但需要在适当的情况下使用它。</p>
<h3 id="局部对象可能适用于返回值优化"><a href="#局部对象可能适用于返回值优化" class="headerlink" title="局部对象可能适用于返回值优化"></a>局部对象可能适用于返回值优化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span> <span class="params">()</span>    <span class="comment">// 复制版本</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    Widget w;           <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> w;           <span class="comment">// 将w&quot;复制&quot;入返回值</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 将&quot;复制&quot;转换为移动来进行优化？</span></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span> <span class="params">()</span>    <span class="comment">// 移动版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(w);   <span class="comment">//将w移入返回值，不能这样做！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很不幸，这样是不正确的。因为先人就是这样规定的。开个玩笑，因为先人已经比我们领先很多年想到并且解决了这里的优化问题。也就是熟知的RVO(返回值优化)。</p>
<p>编译器如果要在一个桉之返回的函数里忽略对局部对象的复制（或移动），需要满足两个条件：</p>
<ol>
<li>局部对象和返回值性别相同</li>
<li>返回的就是局部对象本身</li>
</ol>
<p>我们现在往上看“复制版本”的函数，两个条件均满足，所以进行返回值优化，实质上该函数并没有复制任何东西。而移动版本的函数不满足第二个规定，返回的不是本身而是引用，并没有优化，编译器就把返回值<code>w</code>移入函数的返回值存储的位置。<code>RVO</code>的那条福音后面又接着说明,即使实施<code>RVO</code>的前提条件满足,但编译器选择不执行复制省略的时候,返回对象必须作为右值处理。这么一来,就等于标准要求:当<code>RVO</code>的前提条件允许时,要么发生复制省略,要么<code>std:: move</code>隐式地被实施于返回的局部对象上。因此，上面的例子中复制版本的函数就可能被编译器优化成移动的版本。</p>
<p>既然如此，就不要使用<code>std::move</code>或者<code>std::forward</code>来对可能适用于优化的局部对象处理。防止排除编译器<code>RVO</code>的实施机会。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符优先级</title>
    <url>/2023/10/11/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<h3 id="运算符优先级的问题"><a href="#运算符优先级的问题" class="headerlink" title="运算符优先级的问题"></a>运算符优先级的问题</h3><p>假如有下面的代码。<span id="more"></span>你想在特定条件下让 <code>high</code>变量的二进制形式左移四位然后加上&#96;low&#96;&#96;:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag &amp; tmp)&#123;</span><br><span class="line">    num1 = high&lt;&lt;<span class="number">4</span> + low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或许你会为了代码可读性，将其更改成下面的格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag &amp; tmp != <span class="number">0</span>) &#123;</span><br><span class="line">    num1 = high&lt;&lt;<span class="number">4</span> + low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很不幸的是，这两个 <code>if</code>语句不能画上等号,因为你没有考虑到运算符优先级的问题，下面的语句实际上是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag &amp; (tmp != <span class="number">0</span>)) &#123;</span><br><span class="line">    num1 = high&lt;&lt;(<span class="number">4</span> + low);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符优先级规则"><a href="#运算符优先级规则" class="headerlink" title="运算符优先级规则"></a>运算符优先级规则</h3><p>是不是与你预想的差之千里，为了更好的使用 C 语言，每个 C coder 都应该牢记下面的几点:</p>
<ul>
<li>优先级最高的不是真正意义上的运算符。eg：数组下表、函数调用操作符、各结构成员选择操作符。它们都是自左向右结合的，这也就是为什么 <code>a.b.c</code>的含义是<code>(a.b).c</code>而不是 <code>a.(b.c)</code>。</li>
<li>单目运算符（概念不清楚就搜一下）的优先级仅次于前述运算符（<code>++</code>运算符 <code>--</code>运算符）。<br>上一条也说了：函数调用操作符是优先级最高的。假如<code>p</code>是一个函数指针，我想通过这个指针来调用对应的函数，那么<code>*p()</code>显而易见错了，因为它会被编译器理解成<code>*(p())</code>，而我想要的效果是 <code>(*p)()</code>。<br>再举个关于前述运算符的例子。<code>*p++</code>，它会被编译器理解成<code>*(p++)</code>，而希望的效果是<code>(*p)++</code>。</li>
<li>比单目运算符优先级低的就是双目运算符了。双目运算符中：算术运算符&gt;移位运算符&gt;关系运算符&gt;逻辑运算符&gt;赋值运算符&gt;条件运算符（三目运算符）。<br>这一条中最重要的几个点就是：</li>
</ul>
<ol>
<li>任何一个逻辑运算符的优先级都要低于任何一个关系运算符。</li>
<li>移位运算符的优先级比算术运算符低，但是高于关系运算符。</li>
<li>6 个关系运算符的优先级不同。其中<code>==</code> 和 <code>!=</code> 优先级低于其他关系运算符的优先级。</li>
<li>逻辑运算符中。按位运算符优先级高于顺序运算符。每个“与”运算符优先级高于对应的“或”运算符。异或运算符介于按位与运算符和按位或运算符之间。</li>
<li>所有的赋值运算符优先级都是一样的（右 -&gt; 左）。eg：<code>a = b = 0;</code> 就是将 <code>a,b</code>赋值为 0。</li>
<li>逗号运算符的优先级最低。<br>例子是举不完，记住这几条结论，在敲代码的时候多留意运算符优先级的问题，用的多了自然就熟练了。<br>也有个偷巧的方法：疯狂加括号，你想让谁先运行就给谁加括号，但是这样不好，会让代码看起来臃肿，不推荐。</li>
</ol>
]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
</search>

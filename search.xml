<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<span id="more"></span></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>中断和动态时钟显示</title>
    <url>/2023/10/18/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%8A%A8%E6%80%81%E6%97%B6%E9%92%9F%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h3 id="外部硬件中断"><a href="#外部硬件中断" class="headerlink" title="外部硬件中断"></a>外部硬件中断</h3><p>外部硬件中断就是从处理器外面来的中断信号，优先级很高。</p>
<p>它的实现是通过两个信号线引入处理器内部的，分别叫<code>NMI</code>和<code>INTR</code>。</p>
<span id="more"></span>


<h4 id="非屏蔽中断（Non-Maskable-Interrupt-NMI）"><a href="#非屏蔽中断（Non-Maskable-Interrupt-NMI）" class="headerlink" title="非屏蔽中断（Non Maskable Interrupt,NMI）"></a>非屏蔽中断（Non Maskable Interrupt,NMI）</h4><p>需要两条线的原因是不一定每一个中断的优先级都需要立刻处理。当涉及到非屏蔽中断，通常是一些紧急且必须立即处理的硬件事件。</p>
<p><strong>硬件中断的优先级管理</strong>：某些系统可能会使用外部硬件中断来处理中断请求的优先级。这意味着当多个中断同时发生时，不是所有中断都需要立即处理。处理器可以为不同的中断信号分配不同的优先级，从而决定哪些中断需要立即处理，而哪些可以等待。</p>
<p>需要立即处理的：</p>
<ul>
<li>电池电量低，系统会发出一个中断告诉处理器快没电了。</li>
<li>内存访问电路有校验错误（读取错误）。</li>
</ul>
<p>不那么着急处理的：</p>
<p>举个例子，一个嵌入式系统可能有多个外部硬件设备连接到处理器，包括键盘、鼠标和网络适配器。如果用户同时按下键盘上的按键和鼠标点击，系统可以根据设定的中断优先级来决定哪个中断首先得到处理。通常情况下，键盘中断可能具有较高的优先级，因为用户通常期望键盘响应更快，而鼠标中断则有较低的优先级，因为它不太紧急。</p>
<p>中断信号的来教叫做 <strong>中断源</strong>。传统的兼容模式下，NMI的中断源通过一个<strong>与非门</strong>连接到处理器，处理器的NMI引脚是<strong>高电平有效</strong>，中断信号是<strong>低电平</strong>有效,也就是NMI引脚是低电平则没有中断。</p>
<p>即使NMI与非门的输出为高时，也不能立刻被识别，还需要<strong>至少</strong>维持4个以上的时钟周期才算有效。</p>
<p>处理器还应当知道发生了什么事，以便于采用适当的处理措施。每个类型的中断都被统一编号，被称为中断类型号、中断向量或者中断号。而有些比较严重的事件就在实模式下被赋予了统一的中断号 2 ，一旦发生 2 号中断，处理器和软件系统通常会放弃继续正常工作的念头，也不会试图纠正已经发生的问题和错误。</p>
<h4 id="可屏蔽中断-Interrupt-Request-INTR-1-7-4-9-2-5"><a href="#可屏蔽中断-Interrupt-Request-INTR-1-7-4-9-2-5" class="headerlink" title="可屏蔽中断(Interrupt Request,INTR)1,7,4,9,2,5"></a>可屏蔽中断(Interrupt Request,INTR)1,7,4,9,2,5</h4><p>由于可能有多台设备同时发送中断请求，但是处理器每次只能处理一个中断，这就需要一个中间层进行仲裁，优先处理优先级更高的。个人计算机中使用最多的就是<code>8259芯片</code>。Intel处理器允许256个中断，8259负责15个不固定的中断号，8个中断输入引脚。引脚的<code>IR0</code>优先级向<code>IR7</code>递减，从片是级联在主片的<code>IR2</code>引脚。</p>
<p>个人计算机中有两块<code>8259芯片</code>，并且两块的关系是级联：主片的<code>INT输出</code>直接送到处理器<code>INTR</code>引脚；从片的<code>INT输出</code>送到第一块的引脚2上，一共提供15个中断信号。</p>
<ul>
<li>主片的引脚 0 接的是系统定时器&#x2F;定时器芯片，主片的端口号是<code>0x20</code>和<code>0x21</code></li>
<li>从片的引脚 0 接的是实时时钟芯片(RTC)，从片的端口号是<code>0xa0</code>和<code>0xa1</code></li>
</ul>
<p>8259内部有中断屏蔽寄存器（IMR）8位寄存器，对应八个引脚，对应的位 <strong>0 表示允许，1 表示阻断</strong>。</p>
<p>即使中断从8529发送出去，最终解释权也归处理器。处理器内部的标志寄存器有个<code>IF</code>标志位（中断标志）。当<code>IF</code>为0,中断信号被忽略。</p>
<p>对于IF标志位的处理有两条指令:<code>cli</code>（Clear Interrupt Flag）和<code>sti</code>(SeT Interrupt flag)。</p>
<p><strong>中断嵌套</strong>：当一个中断事件正在处理时，如果来了优先级更高的中断事件，允许暂时中止当前的中断事件，先为优先级较高的中断事件服务。</p>
<h4 id="实模式下的中断向量表"><a href="#实模式下的中断向量表" class="headerlink" title="实模式下的中断向量表"></a>实模式下的中断向量表</h4><p>中断处理实际上就是处理器执行一段与该中断有关的指令。因为可以识别256个中断，理论上就需要256段程序，在实模式下，处理器要求将它们的入口点集中存放在内存中从地址<code>0x00000</code>到<code>0x003ff</code>，共<code>1kb</code>的空间内，这就是中断向量表（Interrupt Vector Table,IVT）。</p>
<p>每个中断在中断向量表中占2个字，分别是中断处理程序的偏移地址和段地址。</p>
<p>中断发生时，处理器执行完当前指令后会立刻为硬件服务，会先响应中断，告诉处理器处理该中断，然后向8259芯片所要中断号。</p>
<p>处理器拿到中断号会干下面的事情：</p>
<ol>
<li>保护断点的现场。将标志寄存器FLAGS压栈，清除其<code>IF</code>位和<code>TF</code>位（陷阱标志）。然后将当前的<code>CS</code>和<code>IP</code>压栈。(清除<code>IF</code>是因为在此期间不再响应硬件中断，如果希望更高优先级的中断嵌套，可以编写程序时，使用<code>sti</code>开放中断)</li>
<li>执行中断程序。拿到中断号，将其乘4,得到其在中断向量表的偏移地址。从表中取出来对应段地址和偏移地址传入<code>CS</code>和<code>IP</code>。</li>
<li>返回到断点继续执行。所有中断处理程序的最后一条必须是中断返回指令<code>iret</code>。依次恢复<code>IP</code>，<code>CS</code>，<code>FLAGS</code>的原始数值。</li>
</ol>
<p>而<code>NMI</code>不会从外部获得中断号，自动生成中断号码 2,其他过程相同。</p>
<h4 id="实时时钟、CMOS-RAM-和-BCD编码"><a href="#实时时钟、CMOS-RAM-和-BCD编码" class="headerlink" title="实时时钟、CMOS RAM 和 BCD编码"></a>实时时钟、CMOS RAM 和 BCD编码</h4><p>计算机为什么能精准显示日期和时间？在外围设备控制器芯片<code>ICH</code>内部，集成了实时时钟电路（RTC）和两小块由互补金属氧化物材料组成的静态存储器（CMOS RAM）。实时时钟电路负责计时，日期和时间存储在静态存储器中。</p>
<p>实时时钟是全天候跳动的，即使断电。因为主板上有个小电池供电。</p>
<p>日期和时间信息存储在<code>CMOS RAM</code>中，通常有128字节，日期和时间信息只占了一小部分容量，其他空间用于保存整机的配置信息（硬件类型、工作参数、开机密码、辅助设备启动顺序）</p>
]]></content>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>函数声明</title>
    <url>/2023/10/11/%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<h3 id="正确理解函数声明"><a href="#正确理解函数声明" class="headerlink" title="正确理解函数声明"></a>正确理解函数声明</h3><p>看书的时候看到一个很抽象的语句：<br><code>(*(void(*)())0)();</code><br>想必每个C程序员看到这条语句都会觉得难绷。这个表达式实际上是在尝试调用位于地址0处的函数指针。在大多数操作系统中，访问地址0通常是非法的，因为它可能导致程序崩溃或产生未定义的行为。这种操作在一些特殊的底层编程场景中可能有用，但在通常的应用程序中应该避免使用，因为它不安全且不可移植。</p>
<span id="more"></span>


<p>请各位牢记一条十分简单的规则：<strong>按照使用的方式来声明。</strong></p>
<h4 id="声明符与表达式"><a href="#声明符与表达式" class="headerlink" title="声明符与表达式"></a>声明符与表达式</h4><p>声明符（Declaration Specifier）和表达式（Expression）是编程中的两个不同概念，它们有以下异同点：</p>
<p><strong>相同点</strong>：</p>
<ol>
<li><p><strong>语法元素</strong>：声明符和表达式都是编程语言的语法元素，它们用于构建和操作程序中的数据和操作。</p>
</li>
<li><p><strong>用途</strong>：声明符用于声明（或定义）变量、函数、类型或其他标识符，以便程序正确识别和使用这些标识符。表达式用于表示和计算值，它可以包括操作数和操作符，用于执行特定的计算操作。</p>
</li>
</ol>
<p><strong>不同点</strong>：</p>
<ol>
<li><p><strong>含义和作用</strong>：</p>
<ul>
<li><strong>声明符</strong> 用于描述标识符的性质和类型，但不执行计算或操作。它告诉编译器如何分配内存和如何解释标识符的内容。</li>
<li><strong>表达式</strong> 用于表示和计算值，执行特定的计算操作，返回一个结果。表达式可以包括常量、变量、运算符和函数调用等，用于生成新的值。</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
<ul>
<li>声明符示例：<code>int x;</code>（声明一个整数变量x）、<code>void myFunction();</code>（声明一个没有返回值的函数myFunction）。</li>
<li>表达式示例：<code>x + 5</code>（计算x与5的和，返回一个值）、<code>myFunction()</code>（调用函数myFunction，返回其结果）。</li>
</ul>
</li>
<li><p><strong>上下文</strong>：</p>
<ul>
<li><strong>声明符</strong> 通常出现在变量、函数、类型或其他标识符的声明语句中，例如在变量声明、函数原型、结构体定义等地方。</li>
<li><strong>表达式</strong> 通常出现在赋值语句、算术运算、逻辑运算、函数调用等地方，用于执行操作和计算值。</li>
</ul>
</li>
</ol>
<p>总之，声明符用于描述标识符的性质和类型，而表达式用于表示和计算值。它们在编程中扮演不同的角色，但都是构建程序逻辑的重要组成部分。</p>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>任何的C变量的声明都由两部分组成：类型，声明符。最简单的声明符就是单个变量，比如：</p>
<p><code>int tmp;</code></p>
<p>这个声明的含义是：当对其求值时，tmp的类型是<code>int</code>。<br>当然也可以这样写：</p>
<p><code>int ((tmp));</code></p>
<p>这个声明的含义是：当对其求值时，((tmp))的类型是<code>int</code>型，因此也可以推出来tmp的类型是<code>int</code>。<br>同理的逻辑也适用于函数和指针的声明：</p>
<p><code>double func();</code></p>
<p>这个声明的含义是：<code>func()</code>求值的结果是<code>double</code>类型。也就是说，<code>func</code>是一个返回值为<code>double</code>类型的函数。</p>
<p><code>int* p;</code></p>
<p>这个声明的含义是：<code>*p</code>是一个<code>int</code>型数据。也就是说，<code>p</code>是一个指向<code>int</code>型数据的指针。</p>
<p>将上面的声明组合一下：</p>
<p><code>double *func2(),(*func3)();</code></p>
<p>表示<code>*func2()</code>和<code>(*func3())</code>都是浮点类型的声明符。因为<code>()</code>优先级高于<code>*</code>，可以得出：<br><code>func2</code>是一个函数，该函数的返回值是指向<code>double</code>类型数据的指针。<br><code>func3</code>是一个函数指针，其指向的函数的返回值类型是<code>double</code>。</p>
<h4 id="类型转换符"><a href="#类型转换符" class="headerlink" title="类型转换符"></a>类型转换符</h4><p>类型转换符是一种在编程语言中用于改变一个值的数据类型的操作符或关键字。类型转换符允许程序员显式地指定将一个数据类型转换为另一个数据类型的方式。这种操作通常称为类型转换或强制类型转换。在理解了上面的知识点后，如果得到一个声明好的、给定类型的变量，得到它的类型转换符也就不是一件难事。例如：</p>
<p><code>float (*tmp)();</code></p>
<p>表示<code>tmp</code>是一个指向返回值为<code>float</code>类型的函数的指针，那么：</p>
<p><code>float (*)()</code></p>
<p>也就表示为一个“一个指向返回值为<code>float</code>类型的函数的指针”的类型转换符。</p>
<p>可以看下面代码再练习练习：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myFunction</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数实现</span></span><br><span class="line">    <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个函数指针，并初始化为指向myFunction的指针</span></span><br><span class="line">    <span class="type">int</span> (*h)(<span class="type">char</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="comment">// 这里的myFunction的类型就是 int (*)(char *, int),为了便于理解我就全部写出来了</span></span><br><span class="line">    h = (<span class="type">int</span> (*)(<span class="type">char</span> *, <span class="type">int</span>))myFunction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在可以使用h来调用函数</span></span><br><span class="line">    <span class="type">int</span> result = h(<span class="string">&quot;Hello&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p><code>(*fp)();</code></p>
<p>fp是一个<strong>函数指针</strong>，那么<code>*fp</code>就是该指针指向的函数，所以<code>(*fp)()</code>就是调用这个函数的方式。但是，ANSI C 标准允许程序员将上式子简写成<code>fp()</code>，这只是一种<strong>简写</strong>。</p>
<p>看的仔细的读者就会发现，我上面代码调用函数也使用了简写。因此我上面的代码中：<code>int result = h(&quot;Hello&quot;, 1);</code>实际上是<code>int result = (*h)(&quot;Hello&quot;, 1);</code>。</p>
<h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p><code>(*(void(*)())0)();</code>被设计的目的是为了在计算机启动的时候，硬件将调用首地址为0位置的子例程。</p>
<p>你可能会想，为什么不直接：</p>
<p><code>(* 0)()</code></p>
<p>可惜编译器是笨重的。因为运算符<code>*</code>必须要一个指针来进行解引用。而且这个指针还应该是一个函数指针，这样经过运算符<code>*</code>作用后的结果才能作为函数被调用。因此，上式子对<code>0</code>要进行强制类型转换为一个“指向返回值为void类型的函数的指针”。因此就有了下式：</p>
<p><code>(*(void(*)())0)();</code>,让我解释一下这个表达式的各个部分：</p>
<ol>
<li><p><code>void(*)()</code>：这部分表示一个函数指针类型，它指向一个没有参数并且没有返回值的函数。这是一个函数指针类型的定义，但没有指向任何有效函数。</p>
</li>
<li><p><code>0</code>：这是一个空指针，它不指向任何内存地址。</p>
</li>
<li><p><code>(*(void(*)())0)</code>：这部分将空指针转换为一个函数指针，然后尝试通过解引用这个函数指针来调用一个函数。</p>
</li>
<li><p>最后的 <code>();</code> 尝试调用解引用的函数指针，但由于函数指针不指向有效函数，这会导致未定义行为，通常会导致程序崩溃或其他不可预测的结果。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>加载程序（器）的工作流程</title>
    <url>/2023/10/14/%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%EF%BC%88%E5%99%A8%EF%BC%89%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="用户程序头部"><a href="#用户程序头部" class="headerlink" title="用户程序头部"></a>用户程序头部</h3><p>我们知道编译器编译的用户程序和加载器实际上是在不同时间、不同地方、不同的人开发的。因此，双方都不了解对象的结构和功能，此时就需要一个结构来传达必要的信息。在看下面的文章时候最好能完全掌握<a href="https://zhendewokusi.github.io/2023/10/14/%E5%9C%B0%E5%9D%80%E3%80%81section%E3%80%81vstart/#more">地址、section、vstart</a>的内容。</p>
<span id="more"></span>

<p>加载器必须了解一些如何加载用户程序的必要信息。这通常是加载器的编写者和用户程序的编写者互相协商决定的。经验表明，把这个约定的地方放在用户程序的开头，对双方，特别是加载器来说比较方便，这就是用户程序头部。</p>
<p>而用户程序头部是一个段，且是第一个被定义的段，且总是位于整个源程序的开头。</p>
<h4 id="用户程序头部必须包含的信息"><a href="#用户程序头部必须包含的信息" class="headerlink" title="用户程序头部必须包含的信息"></a>用户程序头部必须包含的信息</h4><ol>
<li><p>用户程序的尺寸（单位是字节）。加载器需要根据尺寸来决定读取多少个逻辑扇区。</p>
</li>
<li><p>用户程序的入口点，包含段地址和偏移地址。加载器并不清楚用户程序的分段情况，更不知道第一条要执行的指令在用户程序中的哪个位置。因此，必须在头部中包含第一条指令的段地址和偏移地址，也就是用户程序的入口点。你可能会想，那你上一篇文章也没有这样做呀。甚至没有用户程序头部。是这样的，很多程序可能会有多个代码段，因此需要明确指出用户程序刚开始运行的地址，我的上一篇的例子还是过于理想化了。</p>
</li>
<li><p>段重定位表。还是刚刚说的，一个程序可能会有多个代码段和数据段。这些段如何用归用户程序管，但是程序加载在内存中时地址需要重新确定。</p>
</li>
</ol>
<p>实际上的用户程序头部还包含：校验和信息、外部依赖项、内存布局、硬件要求等等。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>该例子是&lt;&lt;x86汇编 从实模式到保护模式&gt;&gt;中第八章的示例代码。如果需要更多代码，可以<a href="https://github.com/zhendewokusi/codeOfAssembly.git">查看</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTION header vstart=0                     ;定义用户程序头部段 </span><br><span class="line">    program_length  dd program_end          ;程序总长度[0x00]</span><br><span class="line">    </span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start                ;偏移地址[0x04]</span><br><span class="line">                    dd section.code_1.start ;段地址[0x06] </span><br><span class="line">    </span><br><span class="line">    realloc_tbl_len dw (header_end-code_1_segment)/4</span><br><span class="line">                                            ;段重定位表项个数[0x0a]</span><br><span class="line">    </span><br><span class="line">    ;段重定位表           </span><br><span class="line">    code_1_segment  dd section.code_1.start ;[0x0c]</span><br><span class="line">    code_2_segment  dd section.code_2.start ;[0x10]</span><br><span class="line">    data_1_segment  dd section.data_1.start ;[0x14]</span><br><span class="line">    data_2_segment  dd section.data_2.start ;[0x18]</span><br><span class="line">    stack_segment   dd section.stack.start  ;[0x1c]</span><br><span class="line">    </span><br><span class="line">    header_end:                </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="加载器的工作流程"><a href="#加载器的工作流程" class="headerlink" title="加载器的工作流程"></a>加载器的工作流程</h3><h4 id="初始化和决定加载位置"><a href="#初始化和决定加载位置" class="headerlink" title="初始化和决定加载位置"></a>初始化和决定加载位置</h4><p>加载器要加载一个用户程序，需要做两件事情：内存哪儿是空闲的（从哪个物理内存地址开始加载用户程序），用户程序在硬盘哪儿呢？起始逻辑扇区号是什么？</p>
<p>我们来看一看<a href="https://github.com/zhendewokusi/codeOfAssembly/blob/master/booktool/c08/c08_mbr.asm"><strong>mbr</strong></a>的具体细节。来看第六行：<code>app_lba_start equ 100</code>。这里的<code>app_lba_start</code>就是指的就是用户程序起始逻辑扇区号号。你可能会想，我为啥要多此一举，直接传立即数不好吗？有编程语言素养的人一定会理解我说的：程序中尽可能避免 <code>magic number</code> ,它的不好之处我也就不赘述。使用<code>equal</code>也不会占用任何汇编地址，也不会再运行的时候占用任何内存位置。</p>
<p>加载用户程序需要一个确定的内存物理地址，<code>phy_base dd 0x10000</code>示例代码将其初始化为0x10000，你当然可以改成其他地址，只要它是空闲的，且必须16字节对齐。一般情况下，加载器及其栈的地址范围在0xA0000以上，在BIOS和外围设备的范围。</p>
<h4 id="准备加载用户程序"><a href="#准备加载用户程序" class="headerlink" title="准备加载用户程序"></a>准备加载用户程序</h4><p>我们将主引导扇区程序定义为一个段。比如示例代码中：<code>SECTION mbr align=16 vstart=0x7c00</code>,这句话是必要的，因为需要设置<code>vstart</code>。</p>
<p>由于<code>phy_base</code>是一个32位的数，且是低端序列存放的，要先通过物理起始地址计算用于加载用户程序的逻辑段地址，所以是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    mov ax,[cs:phy_base] </span><br><span class="line">    mov dx,[cs:phy_base+0x02]</span><br><span class="line">    mov bx,16        </span><br><span class="line">    div bx            </span><br><span class="line">    mov ds,ax    致高位，低地址存低位，且`phy_base`中是`0x10000`，则这两条指令过后:AX寄存器的数值是`0x00`，DX寄存器中是`0X01`。</span><br><span class="line">之后将物理地址变成16位的段地址，并且传送给`DS`和`ES`寄存器。因为前面提到过的，它必须16字节对齐，因此直接将物理地址右移4位就好了。`AX`中存储的是除的商，余数为0没有意义。</span><br><span class="line"></span><br><span class="line">#### 外围设备及其接口</span><br><span class="line"></span><br><span class="line">接下来加载器就需要访问其他的硬件（eg:硬盘、鼠标、键盘）。因为和计算机主机连接的设备都需要和处理器打交道，就需要一种机制来统一。这里的外接设备都叫做**外围设备**。外围设备分为两种，一种是输入设备，比如键盘、鼠标；另一种是输出设备，比如显示器、打印机。</span><br><span class="line"></span><br><span class="line">而每种设备的工作方式是不一样的。比如扬声器需要的是模拟信号；键盘传输的是**ASCII码**。不同设备传输的信号不一样，插头插孔都不一样、连线的数量也不一样。所以就有了*信号转换器*和*变速齿轮*，这就是**I/O接口**。比如：麦克风，扬声器的I/O接口叫做**声卡**；显示器的I/O接口叫做**显卡**；鼠标、键盘、U盘的I/O接口叫做**USB接口**。看的出来，不同设备的I/O接口不同。</span><br><span class="line"></span><br><span class="line">**I/O接口**可以是电路板，可以是芯片，但是它的本质就是一个变换器。将处理器的信号转换成外围设备能看懂的信号，以及将外围设备的信号转换成处理器能理解的信号。</span><br><span class="line"></span><br><span class="line">问题也随之而来：</span><br><span class="line">- 总不能所有的I/O设备都和处理器相连，如果这样做了，那扩展性也基本上无，该如何解决？</span><br><span class="line">- 每个I/O设备都抢着和处理器信息处理，没有一个合理的机制，一定会发生冲突，这个机制该如何实现？</span><br><span class="line"></span><br><span class="line">第一个问题的解决方法：两者之间加一个中间层，也就是**总线**。比如：USB总线。总线连接所有的外围设备和处理器，且每个连接到总线上的器件**必须**有**电子开关**，这样才能随时和加入和断开。</span><br><span class="line"></span><br><span class="line">第二个问题的解决方法：使用输入输出控制设备集中器（ICH）芯片。它的作用就是连接不同的总线，并且I/O设备对处理器访问的协调工作，也就是南桥。比如ICH连接USB总线、IDE/SATA总线、PCI/PCIE总线（扩展）。而且每个I/O接口可能连接不止一个设备，比如USB接口连接鼠标、键盘、U盘。因为同类型设备不唯一的缘故，它们内部也有线路服用和仲裁的总线体系，叫做通信总线或者设备总线。当处理器想和某个设备交流，ICH就会让其他无关设备闭嘴。</span><br><span class="line"></span><br><span class="line">#### I/O端口和端口访问</span><br><span class="line"></span><br><span class="line">在上面*外围设备及其接口*的基础上来具体说说外围设备和处理器交流之间的细节。</span><br><span class="line"></span><br><span class="line">处理器是通过**端口**来和外围设备打交道的。而端口本质上就是一些处于I/O接口电路中的寄存器。每一个I/O接口都可能有好几个端口，分别用于不同的目的。比如用来连接硬盘的*PATA/SATA*接口就有好几个端口，比如命令端口、状态端口、参数端口和数据端口。由于其本质上是寄存器，因此和处理器内的寄存器类似，都有其对应的数据宽度。比如8位、16位，这是设备和I/O接口制造者之间的协议。</span><br><span class="line"></span><br><span class="line">端口在不同的计算机系统中的实现方式是不同的，比如有些时将其端口号映射到内存地址中（0xE0001 ~ 0x FFFFF），访问这些内存实际上就是在访问对应的I/O接口；也有部分计算机系统是将端口独立编制的，和内存不发生关系。本文只有独立编制的方式。</span><br><span class="line"></span><br><span class="line">所有的端口都是进行统一的编号的，比如：0x0001、0x0002。每个I/O接口电路都会分配多个端口。在Intel系统中，只允许65536个端口存在，端口号范围：0 ~ 65535。由于是进行独立编制的，就不能使用`mov`指令，取而代之的是`in`和`out`指令。</span><br><span class="line"></span><br><span class="line">`in`指令是从端口进行读：</span><br><span class="line">```asm</span><br><span class="line">    in al,dx    ;访问8位端口</span><br><span class="line">    in ax,dx    ;访问16位端口</span><br><span class="line">    in al,0xf0  ;访问0xf0端口</span><br></pre></td></tr></table></figure>
<ol>
<li>目的操作数必须是寄存器<code>AL</code>或者<code>AX</code>。原操作数应该为寄存器<code>DX</code>。</li>
<li><code>in</code>指令不允许使用内存单元当做操作数。</li>
<li>虽然可以使用立即数来指定端口，但是只允许一个字节，不能大于255的端口号。</li>
<li>它并没有影响任何的标志位。</li>
</ol>
<p><code>out</code>指令和<code>in</code>功能相反，因此要求也就是:目的操作数为寄存器<code>DX</code>或者8位立即数。源操作数必须是寄存器<code>AL</code>或者<code>AX</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">out 0x37,al     ;8位端口</span><br><span class="line">out 0xf5,ax     ;16位端口</span><br><span class="line">out dx,al       ;8位端口，端口号在DX中</span><br><span class="line">out dx,ax       ;16位端口，端口号在DX中</span><br></pre></td></tr></table></figure>

<h4 id="通过硬盘控制端口读扇区数据"><a href="#通过硬盘控制端口读扇区数据" class="headerlink" title="通过硬盘控制端口读扇区数据"></a>通过硬盘控制端口读扇区数据</h4><p>我们都知道硬盘读写的基本单位是扇区。每次至少操作一个扇区，不可能仅仅读写一个扇区中的几个字节。者也就是为什么硬盘是典型的块设备，因为数据交换是块。</p>
<h5 id="CHS模式"><a href="#CHS模式" class="headerlink" title="CHS模式"></a>CHS模式</h5><p>回忆一下计算机基础知识，硬盘读写数据都要什么？磁头号、柱面号、扇区号，这就是<code>CHS</code>模式。<br>比如我们可以使用<code>bximage</code>来查看我们创建的<code>*.img</code>文件的信息。其中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  c07 git:(master) ✗ bximage</span><br><span class="line">========================================================================</span><br><span class="line">                                bximage</span><br><span class="line">  Disk Image Creation / Conversion / Resize and Commit Tool for Bochs</span><br><span class="line">         $Id: bximage.cc 14091 2021-01-30 17:37:42Z sshwarts $</span><br><span class="line">========================================================================</span><br><span class="line"></span><br><span class="line">1. Create new floppy or hard disk image</span><br><span class="line">2. Convert hard disk image to other format (mode)</span><br><span class="line">3. Resize hard disk image</span><br><span class="line">4. Commit &#x27;undoable&#x27; redolog to base image</span><br><span class="line">5. Disk image info</span><br><span class="line"></span><br><span class="line">0. Quit</span><br><span class="line"></span><br><span class="line">Please choose one [0] 5</span><br><span class="line"></span><br><span class="line">Disk image info</span><br><span class="line"></span><br><span class="line">What is the name of the image?</span><br><span class="line">[c.img] c07_mbr.img</span><br><span class="line"></span><br><span class="line">disk image mode = &#x27;flat&#x27;</span><br><span class="line">hd_size: 104767488</span><br><span class="line">geometry = 203/16/63 (99 MB)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只用看最后一行的<code>geometry = 203/16/63</code>，它的C（磁头号）就是<code>203</code>,H（柱面号）就是<code>16</code>,S（扇区号）就是<code>63</code>。最早的逻辑扇区编制方法是：<code>LBA28</code>。使用28个比特来表示逻辑扇区号。逻辑扇区一共有2^28个扇区，每个扇区有<code>512</code>字节，一共可管理128G。个人计算机上的主硬盘控制器被分配了8位端口，端口号从0x1f0到0x1f7。</p>
<h5 id="读逻辑扇区，具体过程"><a href="#读逻辑扇区，具体过程" class="headerlink" title="读逻辑扇区，具体过程"></a>读逻辑扇区，具体过程</h5><p>假设要从硬盘上读逻辑扇区，具体过程如下：</p>
<ol>
<li>设置需要读取的扇区数量，这个数值要写入 <code>0x1f2</code> 端口。这是个8位的端口，因此每次只能读写255个扇区，如果写入的值是0,表示读取 256 个扇区。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dx,0x1f2</span><br><span class="line">mov al,0x01</span><br><span class="line">out dx,al</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置其实LBA扇区号。因为扇区的读写是连续的，而<code>LBA28</code>位的编号有足足28位，8086需要将其分割成4段，从低到高分别写入端口<code>0x1f3</code>、<code>0x1f4</code>、<code>0x1f5</code>和<code>0x1f6</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dx,0x1f2</span><br><span class="line">mov al,1</span><br><span class="line">out dx,al                       ;读取的扇区数</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f3</span><br><span class="line">mov ax,si</span><br><span class="line">out dx,al                       ;LBA地址7~0</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f4</span><br><span class="line">mov al,ah</span><br><span class="line">out dx,al                       ;LBA地址15~8</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f5</span><br><span class="line">mov ax,di</span><br><span class="line">out dx,al                       ;LBA地址23~16</span><br><span class="line"></span><br><span class="line">inc dx                          ;0x1f6</span><br><span class="line">mov al,0xe0                     ;LBA28模式，主盘</span><br><span class="line">or al,ah                        ;LBA地址27~24</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>向端口<code>0x1f7</code>写入<code>0x20</code>，请求硬盘读，也是8位端口。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inc dx                          ;0x1f7</span><br><span class="line">mov al,0x20                     ;读命令</span><br><span class="line">out dx,al</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>等待读写操作完成。 向端口<code>0x1f7</code>发送读写命令后，<code>0x1f7</code>端口的第7个标志位为”1”表示正在工作，第3个标志位为”1”表示准备好发送或者接收数据。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.waits:</span><br><span class="line">       in al,dx</span><br><span class="line">       and al,0x88</span><br><span class="line">       cmp al,0x08</span><br><span class="line">       jnz .waits                      ;不忙，且硬盘已准备好数据传输 </span><br></pre></td></tr></table></figure>
<p>不是上面刚说了不要有<code>magic number</code>嘛？这里的<code>0x88</code>和<code>0x08</code>是什么鬼？先看<code>add al,0x88</code>因为<code>0x88</code>的二进制形式是<code>1000 1000</code>。第7位和第3位为1,有没有反应过来？又因为是<code>and</code>，这条指令实质上是保留寄存器<code>AL</code>中的第7位和第3位。如果寄存器<code>AL</code>中为<code>00001000</code>就说明是推出等待状态，可以继续往下操作了。</p>
<ol start="5">
<li>接下来就要连续取出数据。<code>0x1f0</code>是硬盘接口的数据接口，是一个16位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从该<strong>端口写入或者读取数据</strong>。下面代码举了个例子，从硬盘中读取一个扇区，将其存放到段寄存器<strong>DS</strong>指定的数据段，偏移量由寄存器<code>BX</code>指定：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       mov cx,256                      ;总共要读取的字节数</span><br><span class="line">       mov dx,0x1f0                    ;数据接口</span><br><span class="line">.readw:</span><br><span class="line">       in ax,dx</span><br><span class="line">       mov [bx],ax</span><br><span class="line">       add bx,2</span><br><span class="line">       loop .readw</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你如果看的仔细，就会发现：那么<code>0x1f1</code>端口是干嘛的？其实<code>0x1f1</code>是错误寄存器，包含了硬盘驱动器最后一次执行命令后的状态（错误原因）。</p>
<h3 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h3><p>上面这些代码如果每次都要自己来写，那也太折磨人了，尤其是多次读写，不得疯掉。处理器支持一种叫过程调用的指令执行机制，叫做例程。它实质就是一段代码，因为每次进行的操作类似，我们像使用C语言的函数一样的思想。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区</span><br><span class="line">                                         ;输入：DI:SI=起始逻辑扇区号</span><br><span class="line">                                         ;      DS:BX=目标缓冲区地址</span><br><span class="line">         push ax</span><br><span class="line">         push bx</span><br><span class="line">         push cx</span><br><span class="line">         push dx</span><br><span class="line">      </span><br><span class="line">         mov dx,0x1f2</span><br><span class="line">         mov al,1</span><br><span class="line">         out dx,al                       ;读取的扇区数</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f3</span><br><span class="line">         mov ax,si</span><br><span class="line">         out dx,al                       ;LBA地址7~0</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f4</span><br><span class="line">         mov al,ah</span><br><span class="line">         out dx,al                       ;LBA地址15~8</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f5</span><br><span class="line">         mov ax,di</span><br><span class="line">         out dx,al                       ;LBA地址23~16</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f6</span><br><span class="line">         mov al,0xe0                     ;LBA28模式，主盘</span><br><span class="line">         or al,ah                        ;LBA地址27~24</span><br><span class="line">         out dx,al</span><br><span class="line"></span><br><span class="line">         inc dx                          ;0x1f7</span><br><span class="line">         mov al,0x20                     ;读命令</span><br><span class="line">         out dx,al</span><br><span class="line"></span><br><span class="line">  .waits:</span><br><span class="line">         in al,dx</span><br><span class="line">         and al,0x88</span><br><span class="line">         cmp al,0x08</span><br><span class="line">         jnz .waits                      ;不忙，且硬盘已准备好数据传输 </span><br><span class="line"></span><br><span class="line">         mov cx,256                      ;总共要读取的字数</span><br><span class="line">         mov dx,0x1f0</span><br><span class="line">  .readw:</span><br><span class="line">         in ax,dx</span><br><span class="line">         mov [bx],ax</span><br><span class="line">         add bx,2</span><br><span class="line">         loop .readw</span><br><span class="line"></span><br><span class="line">         pop dx</span><br><span class="line">         pop cx</span><br><span class="line">         pop bx</span><br><span class="line">         pop ax</span><br><span class="line">      </span><br><span class="line">         ret</span><br></pre></td></tr></table></figure>
<p>这里的<code>ret</code>作用也可以类似C语言的函数来理解，进入函数前需要将参数压入栈中，也就是开始的<code>push ax</code>将操作前的寄存器的数值压入栈中。而<code>ret</code>就类似于<code>return</code>，将压入栈中的数值弹出，恢复各个寄存器的数值。这段代码就是我们说的过程。进入该过程时候，需要将<code>SI</code>和<code>DI</code>存入起始逻辑扇区号，<code>SI</code>存入低16位，<code>DI</code>存入高12位。</p>
<p>那么这个例程我们该如何调用呢？有以下三种调用方式：</p>
<h4 id="16位相对近调用"><a href="#16位相对近调用" class="headerlink" title="16位相对近调用"></a>16位相对近调用</h4><p>近调用意思是说被调用的目标位于当前的代码段内，所以只需要偏移地址就可以了。</p>
<p>调用的地址计算：用目标过程的汇编地址减去当前call指令的汇编地址，再减去<code>call</code>指令的字节长度。<br>这里的代码和调试都是从<a href="https://github.com/zhendewokusi/codeOfAssembly/blob/master/booktool/c08/c08_mbr.asm">c08_mbr.asm</a>得到的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call read_hard_disk_0</span><br></pre></td></tr></table></figure>
<p>只看我们向看的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;bochs:14&gt; </span><br><span class="line">Next at t=17178875</span><br><span class="line">(0) [0x000000007c20] 0000:7c20 (unk. ctxt): call .+81  (0x00007c74)   ; e85100</span><br></pre></td></tr></table></figure>
<p>所以我们可以看出来，这里并不是一个地址，而是一个偏移量。这里需要注意的是如果<strong>调用过程</strong>在当前指令前面，那么相对量是个正数，反之就是负数。再比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call 0x0500</span><br></pre></td></tr></table></figure>
<p>这里本质上和上一个一样，绝不是将<code>0x0500</code>出现在机器码中，而是用这个数值减去当前指令的汇编地址来得到一个偏移量。</p>
<h4 id="16位间接绝对近调用"><a href="#16位间接绝对近调用" class="headerlink" title="16位间接绝对近调用"></a>16位间接绝对近调用</h4><p>这种也是近调用，只能调用当前代码段内的过程，指令中的操作数就不是偏移量了，而是被调用过程的<strong>真实偏移地址</strong>，故成为<strong>绝对地址</strong>。但是！这个偏移地址不是直接出现在指令中，而是由<strong>16位通用寄存器或者16位内存单元</strong>间接给出，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call cx             ;被调用过程的偏移地址位于寄存器CX内，在指令执行时候有处理器从该寄存器中取得</span><br><span class="line">call [0x3000]       ;处理器访问数据段（使用DS）,从偏移地址0x3000处取得一个字作为目标过程的真实偏移地址</span><br><span class="line">call [bx]           ;原理同2</span><br><span class="line">call [bx+si+0x02]   ;原理同2</span><br></pre></td></tr></table></figure>

<h4 id="16位直接绝对远"><a href="#16位直接绝对远" class="headerlink" title="16位直接绝对远"></a>16位直接绝对远</h4><p>这种调用属于段间调用，即调用另一个代码段内的过程，所以被称为远调用。即需要被调用过程所在的段地址，也需要该过程在段内的偏移地址。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call 0x2000:0x0030</span><br></pre></td></tr></table></figure>
<p>当然你想玩个<code>call</code>的被调用过程处于当前代码段内，处理器也会从当前代码段转移到当前代码段。</p>
<h4 id="16位间接绝对远调用"><a href="#16位间接绝对远调用" class="headerlink" title="16位间接绝对远调用"></a>16位间接绝对远调用</h4><p>这也属于段间调用，被调用过程位于另一个代码段内，而且段地址和偏移地址都是间接给出的，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call far [0x2000]</span><br><span class="line">call far [proc_l]</span><br><span class="line">call far [bx]</span><br><span class="line">call far [bx+si]</span><br></pre></td></tr></table></figure>

<p>间接远调用必须使用关键字<code>far</code>。指令中给出的是偏移地址，而段地址在偏移地址的后面。看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc_1 dw 0x0102,0x2000</span><br><span class="line">call far [proc_1]</span><br><span class="line">call far [bx]</span><br><span class="line">call far [bx+si]</span><br></pre></td></tr></table></figure>

<p>当这条指令执行时，处理器访问由段寄存器DS指向的数据段，从指令中指定的偏移地址处取两个字（分别是段地址<code>0x2000</code>和偏移地址<code>0x0102</code>）；然后将代码段寄存器<code>CS</code>和指令指针寄存器<code>IP</code>的当前内容压栈，最后用刚才取得的段地址和偏移地址代替<code>CS</code>和<code>IP</code>的数值。剩下两个也是同理。</p>
<p>而过程调用完就需要返回，叫做<strong>过程返回</strong>。</p>
<h4 id="返回指令-ret"><a href="#返回指令-ret" class="headerlink" title="返回指令 ret"></a>返回指令 <code>ret</code></h4><p>当它执行的时候，处理器只做一件事情，就是从栈中弹出来一个字到指令指针寄存器<strong>IP</strong>中。</p>
<h4 id="返回指令-retf"><a href="#返回指令-retf" class="headerlink" title="返回指令 retf"></a>返回指令 <code>retf</code></h4><p>当它执行的时候，处理器分别从栈中弹出来两个字到指令指针寄存器<code>IP</code>和代码段寄存器<code>CS</code>中。</p>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>在示例代码中，将<code>AX</code>，<code>BX</code>，<code>CX</code>，<code>DX</code>的数值<code>push</code>进了栈，在过程的最后，就是恢复。反序弹出4个寄存器的数值。此时栈指针回到了进入过程内部时的位置（这很重要！）。</p>
<h4 id="加载用户程序"><a href="#加载用户程序" class="headerlink" title="加载用户程序"></a>加载用户程序</h4><p>可以看示例代码<a href="https://github.com/zhendewokusi/codeOfAssembly/blob/master/booktool/c08/c08.asm">c08.asm</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTION header vstart=0                     ;定义用户程序头部段 </span><br><span class="line">    program_length  dd program_end          ;程序总长度[0x00]</span><br><span class="line">    </span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry      dw start                ;偏移地址[0x04]</span><br><span class="line">                    dd section.code_1.start ;段地址[0x06] </span><br><span class="line">    </span><br><span class="line">    realloc_tbl_len dw (header_end-code_1_segment)/4</span><br><span class="line">                                            ;段重定位表项个数[0x0a]</span><br><span class="line">    </span><br><span class="line">    ;段重定位表           </span><br><span class="line">    code_1_segment  dd section.code_1.start ;[0x0c]</span><br><span class="line">    code_2_segment  dd section.code_2.start ;[0x10]</span><br><span class="line">    data_1_segment  dd section.data_1.start ;[0x14]</span><br><span class="line">    data_2_segment  dd section.data_2.start ;[0x18]</span><br><span class="line">    stack_segment   dd section.stack.start  ;[0x1c]</span><br><span class="line">    </span><br><span class="line">    header_end:                </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>和示例代码<a href="https://github.com/zhendewokusi/codeOfAssembly/blob/master/booktool/c08/c08_mbr.asm">c08_mbr.asm</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dx,[2]</span><br><span class="line">mov ax,[0]</span><br><span class="line"></span><br><span class="line">mov bx,512                      ;512字节每扇区</span><br><span class="line">div bx                          ;商存储在AX中，余数存储在DX</span><br><span class="line">cmp dx,0</span><br><span class="line">jnz @1                          ;未除尽，因此结果比实际扇区数少1 </span><br><span class="line">dec ax                          ;已经读了一个扇区，扇区总数减1 </span><br></pre></td></tr></table></figure>

<p>前两条指令是将<code>program_length</code>也就是整个程序的大小的高16位置传送到寄存器<code>DX</code>，低16位寄存器传送到寄存器<code>AX</code>中。</p>
<h6 id="cmp-jz-jnz指令理解"><a href="#cmp-jz-jnz指令理解" class="headerlink" title="cmp jz jnz指令理解"></a>cmp jz jnz指令理解</h6><p><code>cmp</code>指令中，如果两个操作数相等，则ZF被设置为1，表示条件为假或”等于零”；如果ZF为0，表示条件为真或”不等于零”。你可能觉得反直觉，<code>cmp</code>指令本质上是将两个数字相减，如果是 0 就将ZF设置为 1。</p>
<p><code>jz</code> 和 <code>jnz</code> 指令分别根据 ZF 的状态来决定是否跳转。具体来说：</p>
<ul>
<li><code>jnz</code>（Jump if Not Zero）指令会在ZF标志位不等于1时跳转，也就是在条件为真（不等于零）时跳转。</li>
<li><code>jz</code>（Jump if Zero）指令会在ZF标志位等于1时跳转，也就是在条件为假（等于零）时跳转。</li>
</ul>
<p>简单记就是：如果条件为真，也就是 1 ,也就是”if Not Zero”，也就对应了<code>jnz</code>，<code>jz</code>同理。</p>
<p>有了上面的知识储备，让我们来看下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> cmp dx,0</span><br><span class="line"> jnz @1                          </span><br><span class="line"></span><br><span class="line">@1:</span><br><span class="line">      cmp ax,0                        ;考虑实际长度小于等于512个字节的情况 </span><br><span class="line">      jz direct</span><br><span class="line">      </span><br><span class="line">      ;读取剩余的扇区</span><br><span class="line">      push ds                         ;以下要用到并改变DS寄存器 </span><br><span class="line"></span><br><span class="line">      mov cx,ax                       ;循环次数（剩余扇区数）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果<code>dx != 0</code>那么就跳入<code>@1</code>标签内。而下面是如果<code>ax == 0</code>就进入标签<code>dircrt</code>处执行指令。</p>
]]></content>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>地址、section、vstart</title>
    <url>/2023/10/14/%E5%9C%B0%E5%9D%80%E3%80%81section%E3%80%81vstart/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我在学习汇编的时候，对于<code>vstart</code>的概念其实很模糊，感觉会又感觉不是很会，要说哪儿不会有说不出来，就很难受。<code>vstart</code>是<code>section</code>中的概念，但是要讲清楚什么是<code>section</code>，就必须说说什么是地址了。</p>
<span id="more"></span>

<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><h4 id="地址的概念"><a href="#地址的概念" class="headerlink" title="地址的概念"></a>地址的概念</h4><p>计算机里面只有0和1,地址当然就是一串数字，这串数字用来描述各种符号在源程序中的位置。地址细分又能分为：物理地址、虚拟地址布拉布拉的，这里不做深究。</p>
<p>在汇编中，由于指令和变量占据的内存大小不一样，总不能想怎么来就怎么来，那么就得有一套统一的规则来分配。程序中各种数据结构的访问，本质上是通过“该数据结构的起始地址 + 该数据结构在该硬件平台规定的变量所占据的内存大小”来实现的。这里也就解释了，为什么<code>C语言</code>等高级语言中为什么要定义变量的类型，因为这样才能正确的分配和访问变量占据的内存。</p>
<p>那么这里的起始地址是如何得到的呢？编译器在做这件事情的时候，占据第一位的数据的地址便是整个程序的起始地址，后面的数据都是在它基础上的偏移。第n个数据所在的位置就是：第n-1个数据的偏移 + 数据 n-1 的内存空间，这就是所谓的<strong>偏移量</strong>，每个变量的地址都是前一个变量的地址 + 前一个变量的内存空间大小。</p>
<h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><p>来看个简单例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  mov ax,$$</span><br><span class="line">  mov ds,ax</span><br><span class="line">  mov ax,[var]</span><br><span class="line">  label : mov ax,$</span><br><span class="line">  jmp label</span><br><span class="line">  var dw 0x99</span><br><span class="line">  infi: jmp near infi                 ;无限循环</span><br><span class="line"></span><br><span class="line">times (510-($-$$)) db 0               ;主引导程序512字节，空余的使用0填充</span><br><span class="line">          db 0x55,0xaa                ;结束标志               </span><br></pre></td></tr></table></figure>
<p>下面将其放在bochs中进行调试的输出信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;bochs:1&gt; b 0x07c00</span><br><span class="line">&lt;bochs:2&gt; c</span><br><span class="line">(0) Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">Next at t=17178863</span><br><span class="line">(0) [0x000000007c00] 0000:7c00 (unk. ctxt): mov ax, 0x0000            ; b80000</span><br><span class="line">&lt;bochs:3&gt; n</span><br><span class="line">Next at t=17178864</span><br><span class="line">(0) [0x000000007c03] 0000:7c03 (unk. ctxt): mov ds, ax                ; 8ed8</span><br><span class="line">&lt;bochs:4&gt; </span><br><span class="line">Next at t=17178865</span><br><span class="line">(0) [0x000000007c05] 0000:7c05 (unk. ctxt): mov ax, word ptr ds:0x000d ; a10d00</span><br><span class="line">&lt;bochs:5&gt; </span><br><span class="line">Next at t=17178866</span><br><span class="line">(0) [0x000000007c08] 0000:7c08 (unk. ctxt): mov ax, 0x0008            ; b80800</span><br><span class="line">&lt;bochs:6&gt; </span><br><span class="line">Next at t=17178867</span><br><span class="line">(0) [0x000000007c0b] 0000:7c0b (unk. ctxt): jmp .-5  (0x00007c08)     ; ebfb</span><br><span class="line">&lt;bochs:7&gt; </span><br><span class="line">Next at t=17178868</span><br><span class="line">(0) [0x000000007c08] 0000:7c08 (unk. ctxt): mov ax, 0x0008            ; b80800</span><br><span class="line">&lt;bochs:8&gt; </span><br><span class="line">Next at t=17178869</span><br><span class="line">(0) [0x000000007c0b] 0000:7c0b (unk. ctxt): jmp .-5  (0x00007c08)     ; ebfb</span><br></pre></td></tr></table></figure>
<p>可以看到第一行的mov指令，<code>$$</code>被替换成了<code>0</code>。默认情况下如果程序没有定义<code>section</code>就将所有的文件当作一个大的<code>section</code>，因此此时<code>$$</code>为<code>0</code>。</p>
<p>第三行引用了<code>var</code>变量的值，而<code>[]</code>是去所在地址的内容。<code>mov ax, word ptr ds:0x000d ;</code>就是表明要将一个16位的数据从内存地址 <code>0x000d</code> 处加载到寄存器 <code>AX</code> 中。至于为什么是<code>0x000d</code>后面会解释。</p>
<p>第四行用了一个<code>$</code>标号，代表当前指令所在的地址。</p>
<p>最后一行就是一个数据的定义，没什么好讲的。</p>
<p>还记得上面讲的地址的计算吗？看调试第一行的左侧的地址<code>0x000000007c00</code>和第二行地址<code>0x000000007c03</code>，这两个之间相差3,而第一个指令转换成机器码是<code>b80000</code>刚好三个字节。有没有理解计算机的地址了？再依次往下算，刚好<code>var dw 0x99</code>的地址就是<code>0x000000007c0b</code> + 对应的机器码<code>ebfb</code>的长度，也就是<code>0x000000007c0d</code>，就将这个结果<code>0x000000007c0d - 0x000000007c00</code> 后得到的偏移量是不是 <code>0x000d</code>，也就是变量<code>var</code>的地址。</p>
<h3 id="section"><a href="#section" class="headerlink" title="section"></a>section</h3><p>我刚开始对<code>section</code>感觉就是在似懂非懂，这个东西称为节。编译器提供的这个关键字只是给程序员用的，处理器根本不知道有这么个东西，你会想：既然CPU又不知道这么个东西，我用不用<code>section</code>都行吧。是这样的，但是最好使用，因为<code>section</code>的功能类似与函数，人为的将代码划分为不同的部分，都是为了代码结构清晰，易于维护。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTION code</span><br><span class="line">    mov ax,$$</span><br><span class="line">    mov ax,section.data.start</span><br><span class="line">    mov ax,section.code.start</span><br><span class="line">    mov ax,[var1]</span><br><span class="line">    label: jmp label</span><br><span class="line"></span><br><span class="line">    infi: jmp near infi                 ;无限循环</span><br><span class="line"> </span><br><span class="line">  times (510-($-$$)) db 0</span><br><span class="line">            db 0x55,0xaa</span><br><span class="line"></span><br><span class="line">SECTION data</span><br><span class="line">    var1 dd 0x4</span><br></pre></td></tr></table></figure>
<p>下面将其放在bochs中进行调试的输出信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0</span><br><span class="line">&lt;bochs:1&gt; b 0x07c00</span><br><span class="line">&lt;bochs:2&gt; c</span><br><span class="line">(0) Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">Next at t=17178863</span><br><span class="line">(0) [0x000000007c00] 0000:7c00 (unk. ctxt): mov ax, 0x0000            ; b80000</span><br><span class="line">&lt;bochs:3&gt; n</span><br><span class="line">Next at t=17178864</span><br><span class="line">(0) [0x000000007c03] 0000:7c03 (unk. ctxt): mov ax, 0x0200            ; b80002</span><br><span class="line">&lt;bochs:4&gt; </span><br><span class="line">Next at t=17178865</span><br><span class="line">(0) [0x000000007c06] 0000:7c06 (unk. ctxt): mov ax, 0x0000            ; b80000</span><br><span class="line">&lt;bochs:5&gt; </span><br><span class="line">Next at t=17178866</span><br><span class="line">(0) [0x000000007c09] 0000:7c09 (unk. ctxt): mov ax, word ptr ds:0x0200 ; a10002</span><br><span class="line">&lt;bochs:6&gt; </span><br><span class="line">Next at t=17178867</span><br><span class="line">(0) [0x000000007c0c] 0000:7c0c (unk. ctxt): jmp .-2  (0x00007c0c)     ; ebfe</span><br><span class="line">&lt;bochs:7&gt; </span><br><span class="line">Next at t=17178868</span><br><span class="line">(0) [0x000000007c0c] 0000:7c0c (unk. ctxt): jmp .-2  (0x00007c0c)     ; ebfe</span><br></pre></td></tr></table></figure>

<p>在调试信息中我们注意到：</p>
<ul>
<li><p><code>SECTION code</code> 和 <code>SECTION data</code> 一个字节的机器码都没有产生，也印证了前面说的处理器并不知道有<code>SECTION</code>的存在。</p>
</li>
<li><p><code>section.data.start</code>实际上就是本文件中名为<code>data</code>的<code>section</code>的真实偏移。这个或许看不出来，可以看<code>mov ax,section.code.start</code>的偏移，也就是调试信息中的<code>0000:7c06 (unk. ctxt): mov ax, 0x0000</code>，可以看到<code>code</code>的偏移量为0，符合我们的预期。</p>
</li>
</ul>
<h3 id="vstart"><a href="#vstart" class="headerlink" title="vstart"></a>vstart</h3><p>根据nasm官方手册的解释：<code>section</code>使用<code>vstart</code>修饰后，就可以被赋予一个虚拟起始地址<code>virtual start address</code>。而<code>org</code>和<code>vstart</code>实际上是同一功能，我就只展示其中一个，另外一个原理相同。</p>
<p>特别需要注意的是：<code>vstart</code>和<code>org</code>都不会让程序加载到地址xxx。它们做的只是告诉编译器将这个节之后的数据、指令的地址按照xxx为起始，就这么个功能。而加载是加载器的功能，编译器没这本事。</p>
<p>光听概念太枯燥，还是来看个代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTION code vstart=0x7c00</span><br><span class="line">    mov ax,$$</span><br><span class="line">    mov ax,section.data.start</span><br><span class="line">    mov ax,section.code.start</span><br><span class="line">    mov ax,[var1]</span><br><span class="line">    label: jmp label</span><br><span class="line"></span><br><span class="line">    infi: jmp near infi                 ;无限循环</span><br><span class="line"> </span><br><span class="line">  times (510-($-$$)) db 0</span><br><span class="line">            db 0x55,0xaa</span><br><span class="line"></span><br><span class="line">SECTION data </span><br><span class="line">    var1 dd 0x4</span><br></pre></td></tr></table></figure>
<p>下面将其放在bochs中进行调试的输出信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0</span><br><span class="line">&lt;bochs:1&gt; b 0x07c00</span><br><span class="line">&lt;bochs:2&gt; c</span><br><span class="line">(0) Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">Next at t=17178863</span><br><span class="line">(0) [0x000000007c00] 0000:7c00 (unk. ctxt): mov ax, 0x7c00            ; b8007c</span><br><span class="line">&lt;bochs:3&gt; n</span><br><span class="line">Next at t=17178864</span><br><span class="line">(0) [0x000000007c03] 0000:7c03 (unk. ctxt): mov ax, 0x0200            ; b80002</span><br><span class="line">&lt;bochs:4&gt; </span><br><span class="line">Next at t=17178865</span><br><span class="line">(0) [0x000000007c06] 0000:7c06 (unk. ctxt): mov ax, 0x0000            ; b80000</span><br><span class="line">&lt;bochs:5&gt; </span><br><span class="line">Next at t=17178866</span><br><span class="line">(0) [0x000000007c09] 0000:7c09 (unk. ctxt): mov ax, word ptr ds:0x0900 ; a10009</span><br><span class="line">&lt;bochs:6&gt; </span><br><span class="line">Next at t=17178867</span><br><span class="line">(0) [0x000000007c0c] 0000:7c0c (unk. ctxt): jmp .-2  (0x00007c0c)     ; ebfe</span><br><span class="line">&lt;bochs:7&gt; </span><br><span class="line">Next at t=17178868</span><br><span class="line">(0) [0x000000007c0c] 0000:7c0c (unk. ctxt): jmp .-2  (0x00007c0c)     ; ebfe</span><br></pre></td></tr></table></figure>

<p>可以看到<code>code</code>加了<code>vstart</code>后，<code>$$</code>从<code>0</code>变成<code>0x7c00</code>。所以该节中的数据地址从<code>0x7c00</code>为起始编址。这个是虚拟的地址，因为这个程序整个才512字节，根本到不了偏移量为<code>0x7c00</code>。<code>$$</code>以该节的虚拟起始地址为主，如果这个节没有<code>vstart</code>来指定起始地址，就输出在文件中偏移地址。而此时的<code>$</code>就是 当前的新的地址 + 偏移。 </p>
<p><code>section.data.start</code>实际上就是本文件中名为<code>data</code>的<code>section</code>的真实偏移，没有因为<code>vstart</code>改变。</p>
]]></content>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>指针和数组</title>
    <url>/2023/10/10/%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>C 语言中指针和数组这两个概念密不可分，以至于如果没有理解其中一个概念，就无法彻底理解另一个概念。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>很基础的一些知识点我就不重复了。关于数组，需要注意的有两个点：</p>
<ol>
<li>C 语言中只有一维数组，而且编译期间就要知道数组的精确大小。数组的元素可以是任何类型的对象，当然也包含了数组，这也就是多维数组。</li>
<li>对于一个数组，我们其实只能干两件事情：确定数组的大小、获取指向该数组下标为 0 的元素的指针。看到这话你是不是要反驳我了：不对呀，你写博客写糊涂了吧？我还可以<code>arr[1]</code>的操作呀。其实<code>[]</code>操作的本质是通过指针来实现的。比如<code>arr[i] = 1</code>其实上是<code>*(arr + i) = 1</code>，这里的 <code>arr</code>就是指向该数组下标为 0 的元素的指针。<span id="more"></span></li>
</ol>
<p>既然<code>arr[0] = 1</code>本质上是<code>*(arr + 0) = 1</code>，那么我们可以整个活:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>[arr] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>读者可以自行尝试一下，这样的代码是否可行。</p>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><h5 id="二维数组内存相关"><a href="#二维数组内存相关" class="headerlink" title="二维数组内存相关"></a>二维数组内存相关</h5><ul>
<li><p>第一种情况：是直接声明的二维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> rows = <span class="number">3</span>; <span class="comment">// 行数</span></span><br><span class="line">    <span class="type">int</span> cols = <span class="number">4</span>; <span class="comment">// 列数</span></span><br><span class="line">    <span class="type">int</span> arr[rows][cols];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化二维数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            arr[i][j] = i * cols + j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证地址连续性</span></span><br><span class="line">    <span class="type">int</span> *ptr = &amp;arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> isContiguous = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="comment">// 计算下一个元素的地址</span></span><br><span class="line">            <span class="type">int</span> *nextPtr = &amp;arr[i][j];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;arr[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (nextPtr != ptr) &#123;</span><br><span class="line">                isContiguous = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isContiguous) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;二维数组的地址是连续的。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;二维数组的地址不是连续的。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x7fff2f05bb80</span><br><span class="line">0x7fff2f05bb84</span><br><span class="line">0x7fff2f05bb88</span><br><span class="line">0x7fff2f05bb8c</span><br><span class="line">0x7fff2f05bb90</span><br><span class="line">0x7fff2f05bb94</span><br><span class="line">0x7fff2f05bb98</span><br><span class="line">0x7fff2f05bb9c</span><br><span class="line">0x7fff2f05bba0</span><br><span class="line">0x7fff2f05bba4</span><br><span class="line">0x7fff2f05bba8</span><br><span class="line">0x7fff2f05bbac</span><br><span class="line">二维数组的地址是连续的。</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种情况：使用malloc来分配一个二维数组</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> rows = <span class="number">3</span>; <span class="comment">// 行数</span></span><br><span class="line">    <span class="type">int</span> cols = <span class="number">4</span>; <span class="comment">// 列数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用malloc分配内存</span></span><br><span class="line">    <span class="type">int</span> **arr = (<span class="type">int</span> **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        arr[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化二维数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            arr[i][j] = i * cols + j;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">void</span> *)&amp;arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证地址连续性</span></span><br><span class="line">    <span class="type">int</span> *ptr = &amp;arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> isContiguous = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="comment">// 计算下一个元素的地址</span></span><br><span class="line">            <span class="type">int</span> *nextPtr = &amp;arr[i][j];</span><br><span class="line">            <span class="keyword">if</span> (nextPtr != ptr) &#123;</span><br><span class="line">                isContiguous = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isContiguous) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;通过malloc分配的二维数组的地址是连续的。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;通过malloc分配的二维数组的地址不是连续的。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放分配的内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x55b2818142c0</span><br><span class="line">0x55b2818142c4</span><br><span class="line">0x55b2818142c8</span><br><span class="line">0x55b2818142cc</span><br><span class="line">0x55b2818142e0</span><br><span class="line">0x55b2818142e4</span><br><span class="line">0x55b2818142e8</span><br><span class="line">0x55b2818142ec</span><br><span class="line">0x55b281814300</span><br><span class="line">0x55b281814304</span><br><span class="line">0x55b281814308</span><br><span class="line">0x55b28181430c</span><br><span class="line">通过malloc分配的二维数组的地址不是连续的。</span><br></pre></td></tr></table></figure>
<p>通过 <code>malloc</code> 分配的二维数组的地址在内存中通常是不连续的。<code>malloc</code> 函数分配的内存块是堆内存，这些内存块通常在堆中的不同位置。因此，二维数组的各行和各列在内存中可能是分散的，<strong>不一定</strong>是连续的。</p>
<p>当你使用 <code>malloc</code> 分配一个二维数组时，你实际上在堆中创建了一个指向指针的数组，其中每个指针指向一个独立的内存块（一维数组），这些内存块存储了实际的数据。因此，二维数组的不同行在堆中的不同位置，它们不是物理上连续的内存块。</p>
<p>如果你需要连续的内存块以便于优化访问或传递给函数，你可以使用一维数组来模拟二维数组，并在计算索引时手动进行转换，以使其在一维数组中是连续的。这将涉及到一些数学运算，但可以帮助你实现连续内存存储。</p>
<p>如果你需要大规模的多维数组，并且连续内存非常重要，你可能需要考虑使用静态数组或者专门设计的数据结构，而不是 <code>malloc</code> 动态分配的内存。</p>
]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>条款 21 :优先选用 std::make_unique 和std::make_shared, 而非直接使用 new</title>
    <url>/2023/10/09/%E6%9D%A1%E6%AC%BE21/</url>
    <content><![CDATA[<h4 id="使用std-make-shared的理由-代码精简"><a href="#使用std-make-shared的理由-代码精简" class="headerlink" title="使用std::make_shared的理由:代码精简"></a>使用std::make_shared的理由:代码精简</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">upw1</span><span class="params">(std::make_unique&lt;Widget&gt;())</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget&gt; <span class="title">upw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">spw1</span><span class="params">(std::make_shared&lt;Widget&gt;())</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用make系列函数只有一个Widget,代码风格不冗余。</p>
<span id="more"></span>

<h4 id="使用std-make-shared的理由-异常安全性"><a href="#使用std-make-shared的理由-异常安全性" class="headerlink" title="使用std::make_shared的理由:异常安全性"></a>使用std::make_shared的理由:异常安全性</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(std::shared_ptr&lt;MyClass&gt; share_p , <span class="type">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test1</span>(std::<span class="built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="keyword">new</span> MyClass),<span class="built_in">test2</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面代码可能会造成内存泄漏.这和编译器从源代码到目标代码的翻译有关系<br>理想情况test1()运行前发生:</p>
<ol>
<li>“new MyClass”完成评估求值(在堆创建)</li>
<li>new 出来的裸指针被shared_ptr托管(运行shared_ptr的构造函数)</li>
<li>运行test2()<br>而编译器不必按照上述顺序生成代码.当然”new MyClass”必须在shared_ptr的构造函数调用前执行完,但是test2()并没有强制它的运行顺序,也就是说test2()可能在1和2的调用前,调用后,甚至1和2调用之间执行.你可能觉得无伤大雅,但是如果test2()在运行时产生了异常呢?<br>此时第一步动态分配的MyClass会被泄漏.</li>
</ol>
<h5 id="如何解决这个问题呢"><a href="#如何解决这个问题呢" class="headerlink" title="如何解决这个问题呢?"></a>如何解决这个问题呢?</h5><h6 id="分开写"><a href="#分开写" class="headerlink" title="分开写"></a>分开写</h6><p>没错,编译器分不清顺序,你就让它分清就好了,将单独的语句改写成多行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> MyClass,MyDel)</span></span>;<span class="comment">//MyDel是自定义析构器</span></span><br><span class="line"><span class="built_in">test1</span>(std::<span class="built_in">move</span>(spw),<span class="built_in">test2</span>());                  <span class="comment">//移动可以提高效率,并且防止复制对引用计数进行原子的递增操</span></span><br></pre></td></tr></table></figure>
<h6 id="使用std-make-shared"><a href="#使用std-make-shared" class="headerlink" title="使用std::make_shared"></a>使用std::make_shared</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test1</span>(std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(),<span class="built_in">test2</span>());</span><br></pre></td></tr></table></figure>
<p>这里如果test2()先运行且异常,动态还没分配MyClass<br>如果先运行std::make_shared<MyClass>(),动态分配的裸指针会安全的存储在std::shared_ptr对象中,之后test2()异常也能正常析构<br>.<em>std::unique_ptr和std::make_unique同理</em></p>
<h4 id="使用std-make-shared的另一个理由-性能提升"><a href="#使用std-make-shared的另一个理由-性能提升" class="headerlink" title="使用std::make_shared的另一个理由:性能提升"></a>使用std::make_shared的另一个理由:性能提升</h4><p>shared_ptr 直接使用 new 表达式的话,除了要为 MyClass 进行一次内存分配,还要为与其相关联的控制块再进行一次内存分配.<br>而使用make_shared来代替new表达式的话,仅仅需要一次内存分配.</p>
<h4 id="make系列函数也不是万能的"><a href="#make系列函数也不是万能的" class="headerlink" title="make系列函数也不是万能的"></a>make系列函数也不是万能的</h4><p>说了这么多,make系列的函数无论是在异常安全,效率,避免代码冗余都有优势,但是不能排他性的只用make系列函数,因为有些情景下不能使用make系列函数.比如,自定义析构器,无法完美转发大括号初始化物,定义自身版本的operator new和operator delete(shared_ptr).<br>对于operator new和operator delete这种边缘情况就不做解释,知道有这么个东西就可以了.</p>
<h5 id="自定义析构器"><a href="#自定义析构器" class="headerlink" title="自定义析构器"></a>自定义析构器</h5><p>所有的make系列函数不允许使用自定义析构器. std::unique_ptr 和 std::shared_ptr 却都有着允许使用自定义析构器的构造函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> MyDel = [](MyClass* pw) &#123;...&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;MyClass, <span class="title">decltype</span><span class="params">(MyDel)</span>&gt; <span class="title">upw</span><span class="params">(<span class="keyword">new</span> MyClass, MyDel)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> MyClass, MyDel)</span></span>;  <span class="comment">// MyDel是自定义析构器</span></span><br><span class="line"><span class="built_in">test1</span>(std::<span class="built_in">move</span>(spw),<span class="built_in">test2</span>());  <span class="comment">// 移动可以提高效率,并且防止复制对引用计数进行原子的递增操</span></span><br></pre></td></tr></table></figure>
<h5 id="不能完美转发大括号初始化物"><a href="#不能完美转发大括号初始化物" class="headerlink" title="不能完美转发大括号初始化物"></a>不能完美转发大括号初始化物</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> upv = std::make_unique&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>最终upv指涉到的是一个包含10个元素,每个元素值都为20的vector?还是包含两个元素,分别是10,20的vector?但是不能完美转发大括号初始化物该怎么办?<br>答案是make系列的函数对形参进行完美转发的代码使用的是圆括号而非大括号.所以是一个包含10个元素,每个元素值都为20的vector.也不是不能完美转发,变通以下还是可以的.比如下面的test1()创建一个std::initializer_list对象,并且利用std::initializer_list型别的构造函数构造vector.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> upv =</span><br><span class="line">        std::make_unique&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(std::initializer_list&lt;<span class="type">int</span>&gt;&#123;<span class="number">10</span>, <span class="number">20</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> initlist = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(initlist);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::unique_ptr elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : *upv) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::shared_ptr elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : *spv) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> upv = std::make_unique&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::unique_ptr elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : *upv) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::shared_ptr elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : *spv) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次运行test1()和test2()得到的结果是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  tmp git:(main) ✗ ./tmp</span><br><span class="line">std::unique_ptr elements: 10 20 </span><br><span class="line">std::shared_ptr elements: 10 20 </span><br><span class="line">std::unique_ptr elements: 20 20 20 20 20 20 20 20 20 20 </span><br><span class="line">std::shared_ptr elements: 20 20 20 20 20 20 20 20 20 20</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> initlist = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(initlist);</span><br></pre></td></tr></table></figure>
<p>对于test1()中upv和spv的初始化,我更希望能使用第二种,没有人会想写第一种那么复杂的代码的.示例代码仅仅展示auto推导出来的类型.</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>条款23：理解std::move 和 std::forward</title>
    <url>/2023/10/09/%E6%9D%A1%E6%AC%BE23/</url>
    <content><![CDATA[<h3 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h3><p><code>std::move</code> 不做任何移动， <code>std::forward</code> 不做任何转发。它们在运行的时候什么都没干。<br>它们两个都只做了<strong>强制类型转换</strong>，<code>std::move</code> 无条件将实参强制转换成右值，<code>std::forward</code> 是有条件的执行强制类型转换。</p>
<span id="more"></span>
<h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><p>我们来看一看<code>c++11</code>中std::move的示例实现:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也和条款9呼应，也就是别名声明(<code>using</code>)压倒<code>typedef</code>的优势：支持模板化！而<code>typedef</code>需要结构体来辅助完成同样功能。如果我们要使用<code>typedef</code>来实现同样的功能的话，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StructReturnType</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> StructReturnType&lt;T&gt;::type&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果是<code>c++14</code>，有了返回值型别推导，实现<code>std::move</code>就更加方便：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = std::<span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span>&amp; x_ref = x;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; rvalue_ref_1 = <span class="built_in">move</span>(x);       <span class="comment">//编译通过，说明强制转换成功</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; rvalue_ref_2 = <span class="built_in">move</span>(x_ref);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::move</code><strong>只做强制类型转换，不做移动</strong>。当然右值是可以实施移动的，所以一个对象实施了<code>std::move</code>后就告诉编译器该对象可能具备移动的条件。为什么是可能呢？通常情况下的确没有问题，具备移动的条件。看下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(std::string tmp)</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的<code>explicit</code> 是一个关键字，通常用于类的构造函数声明中，用于阻止隐式类型转换。当一个构造函数被标记为 <code>explicit</code> 时，它告诉编译器不要执行隐式类型转换，只有显式调用时才会使用该构造函数。</p>
<p><code>Entity</code>类的构造函数不需要修改<code>tmp</code>，根据优良传统“只要有可能使用<code>const</code>就使用”，将代码更改成了下面的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="type">const</span> std::string tmp)</span></span></span><br><span class="line"><span class="function">    : value(std::move(tmp))&#123;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码顺利运行，但是<code>tmp</code>是被复制近<code>value</code>的，而不是移动。<code>std::move(tmp)</code>后结果是右值<code>const std::string</code>，常量性保留下来了。<br>可以浅浅的看一下string的头文件:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//string 文件</span></span><br><span class="line">   <span class="keyword">using</span> string    = basic_string&lt;<span class="type">char</span>&gt;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//basic_string.h 文件</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//复制构造函数</span></span><br><span class="line">   <span class="built_in">basic_string</span>(<span class="type">const</span> basic_string&amp; __str)</span><br><span class="line">     : _M_dataplus(_M_local_data(),</span><br><span class="line">	    _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))</span><br><span class="line">     &#123;</span><br><span class="line">_M_construct(__str._M_data(), __str._M_data() + __str.<span class="built_in">length</span>(),</span><br><span class="line">	     std::forward_iterator_tag());</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//移动构造函数</span></span><br><span class="line">   <span class="built_in">basic_string</span>(basic_string&amp;&amp; __str) <span class="keyword">noexcept</span></span><br><span class="line">     : _M_dataplus(_M_local_data(), std::<span class="built_in">move</span>(__str._M_get_allocator()))</span><br><span class="line">     &#123;</span><br><span class="line"><span class="keyword">if</span> (__str._M_is_local())</span><br><span class="line">  &#123;</span><br><span class="line">    traits_type::<span class="built_in">copy</span>(_M_local_buf, __str._M_local_buf,</span><br><span class="line">		      __str.<span class="built_in">length</span>() + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _M_data(__str._M_data());</span><br><span class="line">    _M_capacity(__str._M_allocated_capacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Must use _M_length() here not _M_set_length() because</span></span><br><span class="line"><span class="comment">// basic_stringbuf relies on writing into unallocated capacity so</span></span><br><span class="line"><span class="comment">// we mess up the contents if we put a &#x27;\0&#x27; in the string.</span></span><br><span class="line">_M_length(__str.<span class="built_in">length</span>());</span><br><span class="line">__str._M_data(__str._M_local_data());</span><br><span class="line">__str._M_set_length(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到移动构造的函数只能接受非常量的<code>string</code>类型的右值引用作为形参。因为指涉到常量的左值引用允许绑定在一个常量右值性别的形参，最终调用的是<code>string</code>的复制构造函数（即使tmp为右值）。</p>
<p>通过这个例子，我们可以学习到：</p>
<ul>
<li>如果想取得对某个对象执行移动操作的能力，不要将其声明为常量。</li>
<li><code>std::move</code>不能保证强制型别转换的对象具备可移动的能力。</li>
<li>唯一可以确定的，结果是个右值。</li>
</ul>
<h3 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h3><p>需要注意的是：传递给 std::forward 的实参型别应当是个非引用型别,因为习惯上它编码的所传递<br>实参应该是个右值(参见条款 28)。<br><code>std::forward</code> 仅仅在特定情况下会实施强制类型转换。最常见的就是某个函数模板取用了万能引用型别作为形参，传递给另一个函数,如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> Entity&amp; left)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Entity&amp;&amp; right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">func</span>(param);</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Entity <span class="title">e</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="built_in">func2</span>(e);</span><br><span class="line">    <span class="built_in">func2</span>(std::<span class="built_in">move</span>(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望<code>func2</code>传入的是一个左值时，执行<code>func</code>的左值的版本，传入的是个右值的时候执行<code>func</code>重载的右值的版本。但是函数形参都是左值，也就是说这里的<code>param</code>一直是左值，不论传入<code>func2</code>的是左值还是右值，都只会执行<code>func</code>的左值版本。此时，<code>std::forward</code>就做到了这件事：仅当实参是右值完成初始化的时候才会执行向右值的强制类型转换。</p>
<p>那么<code>std::forward</code>是如何知道实参是否通过右值来完成初始化的呢？其实是通过传入的函数模板形参<code>T</code>来实现的(详细参见条款 28)。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>条款24:区分万能引用和右值引用</title>
    <url>/2023/10/12/%E6%9D%A1%E6%AC%BE24/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不是所有的<code>&amp;&amp;</code>都是右值引用！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(Widget&amp;&amp; param)</span></span>;    <span class="comment">// 右值引用</span></span><br><span class="line">Widget&amp;&amp; varl = <span class="built_in">Widget</span>();   <span class="comment">// 右值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = van;          <span class="comment">// 不是右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std: :vector&lt;T&gt;&amp;&amp; param)</span></span>;    <span class="comment">// 右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;          <span class="comment">// 不是右值引用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>好了，看完CPU烧了，到底是不是右值引用呀，我也不知道呀。<br>实际上, “ <code>T&amp;&amp;</code> ”有两种不同的含义。其中一种含义,理所当然,是右值引用。正如期望,它们仅仅会绑定到右值,而其主要的存在理由,在于识别出可移对象。“ <code>T&amp;&amp;</code> “的另一种含义,则表示其既可以是右值引用,亦可以是左值引用。它可以绑定到右值，也可以像左值引用一样，也可以绑定在<code>const</code>对象或者非<code>const</code>对象，也可以绑定在<code>volatile</code>对象或者非<code>volatile</code>对象,它灵活度高到被成为<em>万能引用</em>。</p>
<h3 id="万能引用的场景"><a href="#万能引用的场景" class="headerlink" title="万能引用的场景"></a>万能引用的场景</h3><ol>
<li>函数模板的推导</li>
<li>auto声明</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = van;          <span class="comment">// 不是右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;          <span class="comment">// 不是右值引用</span></span><br><span class="line"><span class="comment">//在这种情况下，类型 T 是需要从参数中推导的，因为 param 的类型是未知的，这时编译器将根据参数类型来推导 T 的类型。</span></span><br></pre></td></tr></table></figure>
<p>这两个场景的共同之处：都涉及<strong>型别推导</strong>。如果看到了<code>T&amp;&amp;</code>但是没有型别推导，那么就可以确定是右值引用。</p>
<h3 id="万能引用的条件"><a href="#万能引用的条件" class="headerlink" title="万能引用的条件"></a>万能引用的条件</h3><p>万能引用的特点是它们具有两个条件：</p>
<ol>
<li><p><strong>必须</strong>在模板内进行型别推导：这意味着类型 T 必须在模板函数或模板类内部通过类型推导而不是显式指定。这是因为模板会根据实际传递给函数或类的参数类型来推导 T 的类型。</p>
</li>
<li><p>型别声明的形式<strong>必须</strong>是 <code>T&amp;&amp;</code>：这表示右值引用的声明必须以 T&amp;&amp; 的形式出现，以指示它可以成为万能引用。</p>
</li>
</ol>
<p>如果这两个条件同时满足，那么右值引用就被认为是万能引用。</p>
<p>这也就是为什么上面提到的<code>void f(std: :vector&lt;T&gt;&amp;&amp; param);</code>是右值引用而不是万能引用。它虽然涉及型别推导，但它的型别声明形式不是 <code>T&amp;&amp;</code>，而是 <code>std::vector&lt;T&gt;&amp;&amp;</code>。因此，这只是一个右值引用，而不是万能引用。</p>
<p>即使只是一个<code>const</code>的存在，也不满足条件2,就成为了右值引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;    <span class="comment">//右值引用</span></span><br></pre></td></tr></table></figure>

<p>如果在一个模板内看到一个函数形参为<code>T&amp;&amp;</code>也不能想当然的认为它是万能引用。看下面的例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span> , <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>push_back</code>的形参满足条件，但是条件一：型别推导，它并没有涉及。因为该函数作为<code>vector</code>类的一部分，如果没有特定<code>vector</code>类实例，就没有该函数（C++类的基础）。如果给定一个<code>vector</code>实例，那么<code>push_back</code>的形参就会被具体化。比如给定一个实例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;Entity&gt; entity;</span><br></pre></td></tr></table></figure>
<p>vector模板就会被具化为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&lt;Entity, allocator&lt;Entity&gt;&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(Entity&amp;&amp; x)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>push_back</code>函数并没有涉及类型推导。因此其参数不是万能引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span> , <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">emplace_back</span>(Args&amp;&amp;... args);  <span class="comment">// 万能引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的<code>args</code>涉及到了类型推导，因此是万能引用。</p>
<h4 id="多说一点"><a href="#多说一点" class="headerlink" title="多说一点"></a>多说一点</h4><p>有些人不清楚<code>template&lt;class... Args&gt;</code>中的<code>...</code>是什么，其实很简单，”…” 是用来表示可变参数模板的语法。它用于表示函数或类模板可以接受可变数量的参数。具体来说，<code>Args</code> 是一个参数包，它可以包含零个或多个模板参数。<code>Args&amp;&amp;... args</code> 表示您可以将任意数量的参数传递给 <code>emplace_back</code> 函数，每个参数都会被表示为 <code>Args</code> 类型的右值引用。这种语法通常用于实现”完美转发”。（后面会提到）</p>
<p>而前面提到的另一种场景,auto声明，在<code>C++11</code>中不怎么普遍。而在<code>C++14</code>中，它现身的机会就更多了，因为<code>C++14</code>中的<code>lambda</code>表达式中可以声明<code>auto&amp;&amp; </code>的形参。</p>
<h3 id="万能引用的作用"><a href="#万能引用的作用" class="headerlink" title="万能引用的作用"></a>万能引用的作用</h3><p>这种引用在模板编程中非常有用，因为它们能够保持对传递给它们的参数的左值或右值性质，并且可以实现完美转发，使它们适用于各种不同类型的参数。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>条款25:针对右值引用实施std::move，针对万能引用实施std::forward</title>
    <url>/2023/10/12/%E6%9D%A1%E6%AC%BE25/</url>
    <content><![CDATA[<h3 id="重载？"><a href="#重载？" class="headerlink" title="重载？"></a>重载？</h3><p>在条款23的基础上，再来细说一下<code>std::move</code>和<code>std::forward</code>。看这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = std::<span class="built_in">move</span>(newName);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::shared_ptr&lt;Data&gt; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::string <span class="title">getEntityName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    <span class="keyword">auto</span> n = <span class="built_in">getEntityName</span>();</span><br><span class="line">    e.<span class="built_in">setName</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看着好像一切安好。<span id="more"></span>注意这里的<code>n</code>是局部变量，传递给<code>e.setName()</code>，调用者假定该函数对<code>n</code>只进行读操作是没有任何问题的。但是<code>setName()</code>内部使用了<code>std::move</code>将其引用的形参无条件强转成右值，因此<code>n</code>的数值就会被移入<code>e.name</code>。运行完<code>setName()</code>后，<code>n</code>就成了一个未知数。</p>
<p>你会说：那我为啥要把形参声明称万能引用自讨苦吃，我直接为其分别重载左值和右值两个版本不就好了。你说的对，但是对的很难受。程序运行效率降低是其次，最主要的是代码难以维护以及扩展性太差。</p>
<p>这个例子只有一个形参，还好处理，两个重载版本就行了。那么10个参数的呢？难不成你重载 (2^{10}) 个版本？有啥想不开的非要这么折磨自己。更别说有些函数模板会有无穷多个形参（比如：<code>std::make_shared</code>）</p>
<h3 id="万能引用！"><a href="#万能引用！" class="headerlink" title="万能引用！"></a>万能引用！</h3><p>上面的例子修改如下，这样就不需要重载也能实现对应功能了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = std::forward&lt;T&gt;(newName); <span class="comment">// 使用 std::forward 来保持左值或右值性质</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::shared_ptr&lt;Data&gt; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::string <span class="title">getEntityName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;NewName&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entity e;</span><br><span class="line">    <span class="keyword">auto</span> n = <span class="built_in">getEntityName</span>();</span><br><span class="line">    e.<span class="built_in">setName</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><p>假设在某个函数中，你刚开始只用了一次该对<br>象，之后就对其实施<code>std::move</code>或者<code>std::forward</code>，这没有问题，需要注意的是，随着函数不断完善，如果在该函数中不止一次地绑定到右值引用或者万能引用，就会导致上面变量<code>n</code>就成了一个未知数的错误。因此，在这种情况下，只能在最后一次使用该引用的时候对其实施<code>std::move</code>或者<code>std::forward</code>来确保其他操作时候其值依旧存在。</p>
<h3 id="std-move-if-noexcept"><a href="#std-move-if-noexcept" class="headerlink" title="std::move_if_noexcept"></a>std::move_if_noexcept</h3><p><code>std::move_if_noexcept</code> 通常用于优化移动操作，特别是在异常安全性方面。它可以帮助在一些情况下，当移动操作不会抛出异常时，避免不必要的拷贝。</p>
<p>这个函数的典型用例是在容器类的 <code>emplace_back</code> 和 <code>emplace</code> 成员函数中，这些函数通常要求插入元素时提供的参数（构造元素的参数）不会抛出异常。这样可以确保在插入元素时，如果构造过程抛出异常，容器的状态不会受到破坏，因为元素的构造是在容器内完成的。</p>
<p>考虑以下示例，使用 <code>std::move_if_noexcept</code> 在 <code>emplace_back</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;MyType&gt; myVector;</span><br><span class="line">myVector.<span class="built_in">emplace_back</span>(std::<span class="built_in">move_if_noexcept</span>(someValue));</span><br></pre></td></tr></table></figure>

<p>在这里，<code>std::move_if_noexcept</code> 会检查 <code>someValue</code> 是否可以进行无异常移动，如果可以，它会使用移动操作，否则会进行拷贝操作。这有助于确保异常安全性，以避免在构造元素时抛出异常时，不会破坏容器的状态。</p>
<p>要使用 <code>std::move_if_noexcept</code>，您需要确保在需要优化移动操作的情况下，并且对于元素类型的移动构造函数声明了 <code>noexcept</code> 说明符。这通常是在实现自定义类时要考虑的事情。</p>
<p>总之，<code>std::move_if_noexcept</code> 是一种有助于提高性能并确保异常安全性的工具，但需要在适当的情况下使用它。</p>
<h3 id="局部对象可能适用于返回值优化"><a href="#局部对象可能适用于返回值优化" class="headerlink" title="局部对象可能适用于返回值优化"></a>局部对象可能适用于返回值优化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span> <span class="params">()</span>    <span class="comment">// 复制版本</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    Widget w;           <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> w;           <span class="comment">// 将w&quot;复制&quot;入返回值</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 将&quot;复制&quot;转换为移动来进行优化？</span></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span> <span class="params">()</span>    <span class="comment">// 移动版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(w);   <span class="comment">//将w移入返回值，不能这样做！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很不幸，这样是不正确的。因为先人就是这样规定的。开个玩笑，因为先人已经比我们领先很多年想到并且解决了这里的优化问题。也就是熟知的RVO(返回值优化)。</p>
<p>编译器如果要在一个桉之返回的函数里忽略对局部对象的复制（或移动），需要满足两个条件：</p>
<ol>
<li>局部对象和返回值性别相同</li>
<li>返回的就是局部对象本身</li>
</ol>
<p>我们现在往上看“复制版本”的函数，两个条件均满足，所以进行返回值优化，实质上该函数并没有复制任何东西。而移动版本的函数不满足第二个规定，返回的不是本身而是引用，并没有优化，编译器就把返回值<code>w</code>移入函数的返回值存储的位置。<code>RVO</code>的那条福音后面又接着说明,即使实施<code>RVO</code>的前提条件满足,但编译器选择不执行复制省略的时候,返回对象必须作为右值处理。这么一来,就等于标准要求:当<code>RVO</code>的前提条件允许时,要么发生复制省略,要么<code>std:: move</code>隐式地被实施于返回的局部对象上。因此，上面的例子中复制版本的函数就可能被编译器优化成移动的版本。</p>
<p>既然如此，就不要使用<code>std::move</code>或者<code>std::forward</code>来对可能适用于优化的局部对象处理。防止排除编译器<code>RVO</code>的实施机会。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>条款26.md</title>
    <url>/2023/10/17/%E6%9D%A1%E6%AC%BE26/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符优先级</title>
    <url>/2023/10/11/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<h3 id="运算符优先级的问题"><a href="#运算符优先级的问题" class="headerlink" title="运算符优先级的问题"></a>运算符优先级的问题</h3><p>假如有下面的代码。<span id="more"></span>你想在特定条件下让 <code>high</code>变量的二进制形式左移四位然后加上&#96;low&#96;&#96;:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag &amp; tmp)&#123;</span><br><span class="line">    num1 = high&lt;&lt;<span class="number">4</span> + low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或许你会为了代码可读性，将其更改成下面的格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag &amp; tmp != <span class="number">0</span>) &#123;</span><br><span class="line">    num1 = high&lt;&lt;<span class="number">4</span> + low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很不幸的是，这两个 <code>if</code>语句不能画上等号,因为你没有考虑到运算符优先级的问题，下面的语句实际上是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag &amp; (tmp != <span class="number">0</span>)) &#123;</span><br><span class="line">    num1 = high&lt;&lt;(<span class="number">4</span> + low);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符优先级规则"><a href="#运算符优先级规则" class="headerlink" title="运算符优先级规则"></a>运算符优先级规则</h3><p>是不是与你预想的差之千里，为了更好的使用 C 语言，每个 C coder 都应该牢记下面的几点:</p>
<ul>
<li>优先级最高的不是真正意义上的运算符。eg：数组下表、函数调用操作符、各结构成员选择操作符。它们都是自左向右结合的，这也就是为什么 <code>a.b.c</code>的含义是<code>(a.b).c</code>而不是 <code>a.(b.c)</code>。</li>
<li>单目运算符（概念不清楚就搜一下）的优先级仅次于前述运算符（<code>++</code>运算符 <code>--</code>运算符）。<br>上一条也说了：函数调用操作符是优先级最高的。假如<code>p</code>是一个函数指针，我想通过这个指针来调用对应的函数，那么<code>*p()</code>显而易见错了，因为它会被编译器理解成<code>*(p())</code>，而我想要的效果是 <code>(*p)()</code>。<br>再举个关于前述运算符的例子。<code>*p++</code>，它会被编译器理解成<code>*(p++)</code>，而希望的效果是<code>(*p)++</code>。</li>
<li>比单目运算符优先级低的就是双目运算符了。双目运算符中：算术运算符&gt;移位运算符&gt;关系运算符&gt;逻辑运算符&gt;赋值运算符&gt;条件运算符（三目运算符）。<br>这一条中最重要的几个点就是：</li>
</ul>
<ol>
<li>任何一个逻辑运算符的优先级都要低于任何一个关系运算符。</li>
<li>移位运算符的优先级比算术运算符低，但是高于关系运算符。</li>
<li>6 个关系运算符的优先级不同。其中<code>==</code> 和 <code>!=</code> 优先级低于其他关系运算符的优先级。</li>
<li>逻辑运算符中。按位运算符优先级高于顺序运算符。每个“与”运算符优先级高于对应的“或”运算符。异或运算符介于按位与运算符和按位或运算符之间。</li>
<li>所有的赋值运算符优先级都是一样的（右 -&gt; 左）。eg：<code>a = b = 0;</code> 就是将 <code>a,b</code>赋值为 0。</li>
<li>逗号运算符的优先级最低。<br>例子是举不完，记住这几条结论，在敲代码的时候多留意运算符优先级的问题，用的多了自然就熟练了。<br>也有个偷巧的方法：疯狂加括号，你想让谁先运行就给谁加括号，但是这样不好，会让代码看起来臃肿，不推荐。</li>
</ol>
]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<span id="more"></span></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>条款 21 :优先选用 std::make_unique 和std::make_shared, 而非直接使用 new</title>
    <url>/2023/10/09/%E6%9D%A1%E6%AC%BE21/</url>
    <content><![CDATA[<h4 id="使用std-make-shared的理由-代码精简"><a href="#使用std-make-shared的理由-代码精简" class="headerlink" title="使用std::make_shared的理由:代码精简"></a>使用std::make_shared的理由:代码精简</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">upw1</span><span class="params">(std::make_unique&lt;Widget&gt;())</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget&gt; <span class="title">upw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">spw1</span><span class="params">(std::make_shared&lt;Widget&gt;())</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用make系列函数只有一个Widget,代码风格不冗余。</p>
<span id="more"></span>

<h4 id="使用std-make-shared的理由-异常安全性"><a href="#使用std-make-shared的理由-异常安全性" class="headerlink" title="使用std::make_shared的理由:异常安全性"></a>使用std::make_shared的理由:异常安全性</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(std::shared_ptr&lt;MyClass&gt; share_p , <span class="type">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test1</span>(std::<span class="built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="keyword">new</span> MyClass),<span class="built_in">test2</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面代码可能会造成内存泄漏.这和编译器从源代码到目标代码的翻译有关系<br>理想情况test1()运行前发生:</p>
<ol>
<li>“new MyClass”完成评估求值(在堆创建)</li>
<li>new 出来的裸指针被shared_ptr托管(运行shared_ptr的构造函数)</li>
<li>运行test2()<br>而编译器不必按照上述顺序生成代码.当然”new MyClass”必须在shared_ptr的构造函数调用前执行完,但是test2()并没有强制它的运行顺序,也就是说test2()可能在1和2的调用前,调用后,甚至1和2调用之间执行.你可能觉得无伤大雅,但是如果test2()在运行时产生了异常呢?<br>此时第一步动态分配的MyClass会被泄漏.</li>
</ol>
<h5 id="如何解决这个问题呢"><a href="#如何解决这个问题呢" class="headerlink" title="如何解决这个问题呢?"></a>如何解决这个问题呢?</h5><h6 id="分开写"><a href="#分开写" class="headerlink" title="分开写"></a>分开写</h6><p>没错,编译器分不清顺序,你就让它分清就好了,将单独的语句改写成多行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> MyClass,MyDel)</span></span>;<span class="comment">//MyDel是自定义析构器</span></span><br><span class="line"><span class="built_in">test1</span>(std::<span class="built_in">move</span>(spw),<span class="built_in">test2</span>());                  <span class="comment">//移动可以提高效率,并且防止复制对引用计数进行原子的递增操</span></span><br></pre></td></tr></table></figure>
<h6 id="使用std-make-shared"><a href="#使用std-make-shared" class="headerlink" title="使用std::make_shared"></a>使用std::make_shared</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test1</span>(std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(),<span class="built_in">test2</span>());</span><br></pre></td></tr></table></figure>
<p>这里如果test2()先运行且异常,动态还没分配MyClass<br>如果先运行std::make_shared<MyClass>(),动态分配的裸指针会安全的存储在std::shared_ptr对象中,之后test2()异常也能正常析构<br>.<em>std::unique_ptr和std::make_unique同理</em></p>
<h4 id="使用std-make-shared的另一个理由-性能提升"><a href="#使用std-make-shared的另一个理由-性能提升" class="headerlink" title="使用std::make_shared的另一个理由:性能提升"></a>使用std::make_shared的另一个理由:性能提升</h4><p>shared_ptr 直接使用 new 表达式的话,除了要为 MyClass 进行一次内存分配,还要为与其相关联的控制块再进行一次内存分配.<br>而使用make_shared来代替new表达式的话,仅仅需要一次内存分配.</p>
<h4 id="make系列函数也不是万能的"><a href="#make系列函数也不是万能的" class="headerlink" title="make系列函数也不是万能的"></a>make系列函数也不是万能的</h4><p>说了这么多,make系列的函数无论是在异常安全,效率,避免代码冗余都有优势,但是不能排他性的只用make系列函数,因为有些情景下不能使用make系列函数.比如,自定义析构器,无法完美转发大括号初始化物,定义自身版本的operator new和operator delete(shared_ptr).<br>对于operator new和operator delete这种边缘情况就不做解释,知道有这么个东西就可以了.</p>
<h5 id="自定义析构器"><a href="#自定义析构器" class="headerlink" title="自定义析构器"></a>自定义析构器</h5><p>所有的make系列函数不允许使用自定义析构器. std::unique_ptr 和 std::shared_ptr 却都有着允许使用自定义析构器的构造函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> MyDel = [](MyClass* pw) &#123;...&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;MyClass, <span class="title">decltype</span><span class="params">(MyDel)</span>&gt; <span class="title">upw</span><span class="params">(<span class="keyword">new</span> MyClass, MyDel)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> MyClass, MyDel)</span></span>;  <span class="comment">// MyDel是自定义析构器</span></span><br><span class="line"><span class="built_in">test1</span>(std::<span class="built_in">move</span>(spw),<span class="built_in">test2</span>());  <span class="comment">// 移动可以提高效率,并且防止复制对引用计数进行原子的递增操</span></span><br></pre></td></tr></table></figure>
<h5 id="不能完美转发大括号初始化物"><a href="#不能完美转发大括号初始化物" class="headerlink" title="不能完美转发大括号初始化物"></a>不能完美转发大括号初始化物</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> upv = std::make_unique&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>最终upv指涉到的是一个包含10个元素,每个元素值都为20的vector?还是包含两个元素,分别是10,20的vector?但是不能完美转发大括号初始化物该怎么办?<br>答案是make系列的函数对形参进行完美转发的代码使用的是圆括号而非大括号.所以是一个包含10个元素,每个元素值都为20的vector.也不是不能完美转发,变通以下还是可以的.比如下面的test1()创建一个std::initializer_list对象,并且利用std::initializer_list型别的构造函数构造vector.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> upv =</span><br><span class="line">        std::make_unique&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(std::initializer_list&lt;<span class="type">int</span>&gt;&#123;<span class="number">10</span>, <span class="number">20</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> initlist = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(initlist);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::unique_ptr elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : *upv) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::shared_ptr elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : *spv) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> upv = std::make_unique&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::unique_ptr elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : *upv) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::shared_ptr elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : *spv) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次运行test1()和test2()得到的结果是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  tmp git:(main) ✗ ./tmp</span><br><span class="line">std::unique_ptr elements: 10 20 </span><br><span class="line">std::shared_ptr elements: 10 20 </span><br><span class="line">std::unique_ptr elements: 20 20 20 20 20 20 20 20 20 20 </span><br><span class="line">std::shared_ptr elements: 20 20 20 20 20 20 20 20 20 20</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> initlist = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(initlist);</span><br></pre></td></tr></table></figure>
<p>对于test1()中upv和spv的初始化,我更希望能使用第二种,没有人会想写第一种那么复杂的代码的.示例代码仅仅展示auto推导出来的类型.</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>条款23：理解std::move 和 std::forward</title>
    <url>/2023/10/09/%E6%9D%A1%E6%AC%BE23/</url>
    <content><![CDATA[<h3 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h3><p><code>std::move</code> 不做任何移动， <code>std::forward</code> 不做任何转发。它们在运行的时候什么都没干。<br>它们两个都只做了<strong>强制类型转换</strong>，<code>std::move</code> 无条件将实参强制转换成右值，<code>std::forward</code> 是有条件的执行强制类型转换。</p>
<span id="more"></span>
<h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><p>我们来看一看<code>c++11</code>中std::move的示例实现:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也和条款9呼应，也就是别名声明(<code>using</code>)压倒<code>typedef</code>的优势：支持模板化！而<code>typedef</code>需要结构体来辅助完成同样功能。如果我们要使用<code>typedef</code>来实现同样的功能的话，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StructReturnType</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> StructReturnType&lt;T&gt;::type&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>c++14</code></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符优先级</title>
    <url>/2023/10/11/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<h3 id="运算符优先级的问题"><a href="#运算符优先级的问题" class="headerlink" title="运算符优先级的问题"></a>运算符优先级的问题</h3><p>假如有下面的代码。<span id="more"></span>你想在特定条件下让 <code>high</code>变量的二进制形式左移四位然后加上&#96;low&#96;&#96;:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag &amp; tmp)&#123;</span><br><span class="line">    num1 = high&lt;&lt;<span class="number">4</span> + low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或许你会为了代码可读性，将其更改成下面的格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag &amp; tmp != <span class="number">0</span>) &#123;</span><br><span class="line">    num1 = high&lt;&lt;<span class="number">4</span> + low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很不幸的是，这两个 <code>if</code>语句不能画上等号,因为你没有考虑到运算符优先级的问题，下面的语句实际上是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag &amp; (tmp != <span class="number">0</span>)) &#123;</span><br><span class="line">    num1 = high&lt;&lt;(<span class="number">4</span> + low);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符优先级规则"><a href="#运算符优先级规则" class="headerlink" title="运算符优先级规则"></a>运算符优先级规则</h3><p>是不是与你预想的差之千里，为了更好的使用 C 语言，每个 C coder 都应该牢记下面的几点:</p>
<ul>
<li>优先级最高的不是真正意义上的运算符。eg：数组下表、函数调用操作符、各结构成员选择操作符。它们都是自左向右结合的，这也就是为什么 <code>a.b.c</code>的含义是<code>(a.b).c</code>而不是 <code>a.(b.c)</code>。</li>
<li>单目运算符（概念不清楚就搜一下）的优先级仅次于前述运算符（<code>++</code>运算符 <code>--</code>运算符）。<br>上一条也说了：函数调用操作符是优先级最高的。假如<code>p</code>是一个函数指针，我想通过这个指针来调用对应的函数，那么<code>*p()</code>显而易见错了，因为它会被编译器理解成<code>*(p())</code>，而我想要的效果是 <code>(*p)()</code>。<br>再举个关于前述运算符的例子。<code>*p++</code>，它会被编译器理解成<code>*(p++)</code>，而希望的效果是<code>(*p)++</code>。</li>
<li>比单目运算符优先级低的就是双目运算符了。双目运算符中：算术运算符&gt;移位运算符&gt;关系运算符&gt;逻辑运算符&gt;赋值运算符&gt;条件运算符（三目运算符）。<br>这一条中最重要的几个点就是：</li>
</ul>
<ol>
<li>任何一个逻辑运算符的优先级都要低于任何一个关系运算符。</li>
<li>移位运算符的优先级比算术运算符低，但是高于关系运算符。</li>
<li>6 个关系运算符的优先级不同。其中<code>==</code> 和 <code>!=</code> 优先级低于其他关系运算符的优先级。</li>
<li>逻辑运算符中。按位运算符优先级高于顺序运算符。每个“与”运算符优先级高于对应的“或”运算符。异或运算符介于按位与运算符和按位或运算符之间。</li>
<li>所有的赋值运算符优先级都是一样的（右 -&gt; 左）。eg：<code>a = b = 0;</code> 就是将 <code>a,b</code>赋值为 0。</li>
<li>逗号运算符的优先级最低。<br>例子是举不完，记住这几条结论，在敲代码的时候多留意运算符优先级的问题，用的多了自然就熟练了。<br>也有个偷巧的方法：疯狂加括号，你想让谁先运行就给谁加括号，但是这样不好，会让代码看起来臃肿，不推荐。</li>
</ol>
]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
</search>
